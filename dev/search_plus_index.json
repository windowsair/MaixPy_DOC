{"./":{"url":"./","title":"关于MaixPy","keywords":"","body":"MaixPy 文档 什么是 MaixPy MaixPy 是将 Micropython 移植到 K210（ 一款64位双核带硬件FPU和卷积加速器的 RISC-V CPU, ） 的一个项目， 支持 MCU 常规操作， 更集成了机器视觉和麦克风阵列， 以快速开发具有极低成本和体积实用的 AIOT 领域智能应用。 MicroPython 是基于 Python3 的语法做的一款解析器，包含了 Python3 的大多数基础语法， 主要运行在性能和内存有限的嵌入式芯片上。（注意 Micropython 不包含 Python3 的所有语法） K210 在硬件上集成了机器视觉和机器听觉能力， 是一款定位 AI 和 AIOT 市场的SoC，同时也是一颗方便的MCU， 性能强劲的同时却有着极低的价格。 Micropython 让我们在 K210 上编程更加简单快捷， 我们也将源代码开源在 github 上 比如我们需要寻找I2C总线上的设备，只需要使用如下代码即可实现： from machine import I2C i2c = I2C(I2C.I2C0, freq=100000, scl=28, sda=29) devices = i2c.scan() print(devices) 同样，我们需要实现一个呼吸灯，只需要如下代码： from machine import Timer,PWM import time tim = Timer(Timer.TIMER0, Timer.CHANNEL0, mode=Timer.MODE_PWM) ch = PWM(tim, freq=500000, duty=50, pin=board_info.LED_G) duty=0 dir = True while True: if dir: duty += 10 else: duty -= 10 if duty>100: duty = 100 dir = False elif duty 实时拍照： import sensor import image import lcd lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) while True: img=sensor.snapshot() lcd.display(img) 这篇文档的内容 所有关于 MaixPy 的内容， 包括： 如何选择并得到一款合适自己的模块或者开发板 如何开始上手使用 库和接口（API）文档查询 让我们开始打开 MaixPy 的神奇大门吧 首先我们选择一款适合自己的开发板， 目前有如下几款高性价比的开发板（核心板）： 使用了 Sipeed M1 模块的 Dan dock Sipeed Maix BiT Sipeed Maix Go Sipeed Maixduino 更多硬件的资料请看 Wiki 开发板介绍 要获得这些板子，可以访问Sipeed（矽速）官网www.sipeed.com，或者官方淘宝店 然后请仔细查看左边目录，然后开始使用吧～～ 视频入门教程 视频简单介绍了基本的上手内容，事实上文档上会更加详细， 视频只是提供一个比较直观的入门参考： 建议进入Bilibili登录看高清版本哦， 如果觉得节奏太慢可以右键调速滴～ MaixPy 源码 MaixPy 源码是指 运行在 K210 上的 Micropython 的解析器， 使用 C语言 编写，如果只是想使用MaixPy，不需要了解源码； 如果想参与开发MaixPy的内置功能，可以下载进行开发，欢迎大家提交PR MaixPy 源码托管在 github 分支 自动构建状态 master 本项目主要由 ©Sipeed Co.,Ltd. 维护， 并接受来自开源社区的贡献， 具体贡献这见贡献者列表 MaixPy 文档源码 修改代码后，文档也会随之更新， 文档源码托管在 github 注意： 在编辑文档前必须看文档编写规范 分支 文档自动构建状态 master dev 反馈 关于本文档或者功能或者源码方面的问题，也欢迎提交issue: 反馈 "},"others/what_maix_do.html":{"url":"others/what_maix_do.html","title":"Maix能做哪些事","keywords":"","body":"Powerful Maix Board(k210) Can Do 大多数是在 MaixPy 上已经有 API， 部分可能来自 Maixduino 或者其它开发者～ 人脸检测 MobileNet 物体识别 tiny yolov2 20分类 识别颜色值、找形状、找直线、面部识别等 视频来自 Hardware.ai MNIST 手写数字识别 Feature map 显示 视频播放和录制 NES 游戏模拟器 （FC 红白机） GBA 游戏模拟器 源码 游戏 Quake I 源码 游戏 Doom 源码 MMD 3D 实时渲染 源码 GUI 界面 littlevGL 云台脸部跟踪 麦克风阵列 FFT 频谱图 "},"get_started/get_hardware.html":{"url":"get_started/get_hardware.html","title":"获得开发板","keywords":"","body":"获得开发板 从Sipeed官方淘宝店获得心仪的硬件： 淘宝 需要的硬件 一款开发板 开发板详细资料请看 Wiki， 选择一款合适自己的开发板～ USB Type C 连接线 选用 Type-C 是因为它支持正反插，对开发十分友好 从淘宝官方购买可以询问是否附送， 目前大部分安卓机也在使用 Type C 连接线 屏幕 默认使用 st7789驱动芯片的 LCD （24pin接口）， 分辨率为 320x240 从淘宝官方购买可以询问是否包含 摄像头 默认使用 ov2640 从淘宝官方购买可以询问是否包含 Micro SD 卡 （TF 卡） （可选） 不适用 SD 卡也是可以操作文件的， 在内部 Flash 上已经保留一部分来作为文件系统了，只是 Flash 速度很慢！ 为了方便图片文件快速操作，可以选择购买一张 Micro SD 卡，　 MaixPy　内置了 SPI SD卡协议驱动， 购买时尽量选择速度快协议新的 Micro SD 卡， 比如 SD 2代协议， Class10 的内存卡 因为 K210 没有 SDIO 硬件外设， 所以使用了 SPI 来与 SD 卡通信， 当然，市面上的 SD 卡品质参差不齐， SPI 模式不一定都能兼容， 尽量买正规的卡， 实在有需求请自行定制驱动～～ 如下图， 左边两张卡 MaixPy 的驱动不支持， 中间和右边的都支持， 但是中间的 class10 卡速度最快 ST-Link （用来给开发板 Maix Go 上的 STM32 更新固件） （可选） 如果购买的是 Maix Go， 上面集成了一颗 STM32 芯片， 用来模拟 USB转串口 工具， 以及模拟 JTAG, 如果想后期自行更新其固件，建议购买一个 ST-Link 备用 JTAG 调试器 （可选） K210 这款芯片支持 JTAG 调试， 如果需要调试功能， 需要使用 JTAG 调试器， 请在 Sipeed 官方淘宝店咨询购买。 如果是 Maix Go 开发板， 可以不用另外购买 JTAG 调试器， Maix Go 开发板上面集成了一个 STM32芯片， 可以模拟 JTAG（STM32 使用 CMSIS-DAP 或者 open-ec 固件）， open-ec 固件目前还不支持，后续会支持，请以 open-ec github 项目主页说明为准 "},"get_started/upgrade_firmware.html":{"url":"get_started/upgrade_firmware.html","title":"更新MaixPy固件","keywords":"","body":"更新 MaixPy 固件 连接硬件 连接 Type C 线， 一端到开发板， 一端到电脑 安装驱动 主要是安装串口驱动，因为板子是通过 USB 转串口设备与电脑连接。 根据板子的 USB 转串口芯片型号装驱动。 在 Linux 或者Mac下操作串口， 如果不想每次都使用sudo命令， 执行sudo usermod -a -G dialout $(whoami) 将自己添加到dialout用户组即可，可能需要注销或者重启才能生效 对于 Dan Dock 和 Maix Bit（旧版） 开发板使用了 CH340 ： Linux 不需要装驱动，系统自带了，使用ls /dev/ttyUSB* 即可看到设备号 Windows 在网上搜索 CH340 驱动 下载安装即可，然后可以在设备管理器中看到串口设备 对于 Maix Go 开发板使用了一颗 STM32 来实现模拟串口以及 JTAG功能， 电脑需要安装 FT2232 的驱动，请自行搜索 FT2232 驱动 下载安装 这款 STM32 芯片的固件出厂默认采用 open-ec 的固件， 如果没问题，则会出现一个或者两个串口， 比如 Linux 下出现两个串口 /dev/ttyUSB0 和 /dev/ttyUSB1， 下载和访问串口时请使用 /dev/ttyUSB1。 Windows 也类似。 如果需要重新烧录这个固件，可以从 github 或者 官网下载 open-ec 固件， 然后使用 ST-LINK 连接板子上引出的 STM32 的 SW 引脚（GND, SWDIO, SWCLK）进行烧录。（目前版本的 Go 板子上的 STM32 不支持串口烧录，只能使用 ST-LINK 进行烧录， 有需要请自行购买，或者使用一款板子用 IO 模拟也可以（比如树莓派） ） 除了 open-ec 还有 CMSIS-DAP 固件， 相比 open-ec 可以模拟 JTAG 来对板子进行调试， open-ec 目前还未支持模拟 JTAG， 可以 从官网下载固件， 使用 ST-LINK 对其进行烧录， 在 Linux 下会出现 /dev/ttyACM0 设备 ST-LINK 对 STM32 的烧录方法资料很全，请自行搜索 请注意对 STM32 更新固件和更新 MaixPy 固件是不一样的， 一般情况不需要更新 STM32的固件， 默认的即够用了， STM32 只是一个 USB转串口的工具而已！！！勿混淆。。。 对于 Maixduino开发板 和 Maix Bit 新版带麦克风版本（使用CH552） 开发板 开发板使用了 CH552 芯片来实现 USB 转串口功能，没有 JTAG 模拟功能， 电脑需要安装 FT2232 的驱动，请自行搜索 FT2232 驱动 下载安装 获得升级工具 下载 kflash_gui, 会得到一个压缩包 kflash_gui 是跨平台的，可以在多个系统下工作（包括 Windows、Linux、MacOS、甚至树莓派) 使用勘智（Kendryte）的Windows版本可能部分开发版无法下载成功，请使用 kflash_gui 这个软件来下载 解压到一个文件夹，双击 kflash_gui.exe(/kflsh_gui) 即可运行， Windows下建议右键固定到开始页面 或者固定到任务栏， Linux 下可以自己新建一个kflash_gui.desktop， 修改文件地址， 使用管理员身份复制到/usr/share/application目录，然后在系统菜单界面就可以看到kflash_gui这款应用了 获得固件 发布版本的固件从 github 页面下载 最新提交的代码自动构建生成的固件下载： master 分支 固件为 .bin 结尾或者 .kfpkg 的文件 如何打包kfpkg见 这里 固件命名说明： maixpy_v*_no_lvgl.bin： MaixPy固件, 不带LVGL版本.(LVGL是嵌入式GUI框架, 写界面的时候需要用到) maixpy_v*_full.bin： 完整版的MaixPy固件(MicroPython + OpenMV API + lvgl ) maixpy_v0.3.1_minimum.bin： MaixPy固件最小集合，不支持 MaixPy IDE， 不包含OpenMV的相关算法 face_model_at_0x300000.kfpkg： 人脸模型，放置在地址位 0x300000， 可以和.bin分开多次下载，不冲突 elf.7z： elf 文件，普通用户不用关心，用于死机调试 下载固件到开发板 打开 kflash_gui 应用 然后选择固件、设置选项， 点击下载即可， 更多特性介绍、使用说明见kflash_gui 项目主页 对于最早期的 Maix Go， 如果确认选项是对的，仍然无法下载， 可以尝试将三相拨轮按键拨向 Down 的位置并保持再下载 "},"get_started/power_on.html":{"url":"get_started/power_on.html","title":"点亮板子(开机)","keywords":"","body":"点亮设备，第一次接触MaixPy 连接硬件 连接 Type C 线， 一端电脑一端开发板 查看设备是否已经正确识别： 在 Linux 下可以通过 ls /dev/ttyUSB* 或者 ls /dev/ttyACM* 来查看， 如果没有可以 ls /dev 来找找，具体的设备名跟串口芯片和驱动有关 在 Windows 下可以打开设备管理器来查看 如果没有发现设备， 需要确认有没有装驱动以及接触是否良好 使用串口工具 Linux 使用minicom 或者 screen等工具即可 minicom sudo apt update sudo apt install minicom sudo minicom -s # 然后根据提示设置串口号以及波特率为 115200 等，不懂可以利用搜索工具搜索 # 设置 Backspace 为 DEL 功能 # 设置 linewrap 为 Yes sudo minicom 注意 minicom 的默认配置文件保存需要 sudo 权限，所以使用sudo minicom -s 这里按 A 即可设置设备 按 E 即可设置波特率， 波特率需要设置为 115200 这里按 A 和 R 将设置切换为图中的设置一样， 第一个是为了后面使用 pye 编辑器快捷键不冲突， 第二个自动换行的设置是为了能显示完全输出 设置完后保存退出，下次就不需要再设置了，只需要执行 sudo minicom 即可, 如果不想每次都使用sudo命令， 执行sudo usermod -a -G dialout $(whoami) 将自己添加到dialout用户组即可，可能需要注销或者重启才能生效，注意sudo minicom -s 如果使用默认配置文件还是需要 sudo 进入minicom后点击回车键，即可看到 MaixPy 的交互界面了 输入 help()，可以查看帮助 要退出minicom， 按 Ctrl+A X，按 Enter 确认退出即可 另外，在开发过程中可能串口号会变， 可以在执行 minicom 的时候指定串口号，这样就不用每次串口号变了都设置一遍了，比如：minicom -D /dev/ttyUSB1 -b 115200 Windows 使用如 putty xshell 等工具 然后选择串口模式， 然后设置串口和波特率，打开串口。 然后点击回车键，即可看到 MaixPy 的交互界面了 >>> 输入 help()，可以查看帮助 上图来源： laurentopia 的上手教程 "},"get_started/led_blink.html":{"url":"get_started/led_blink.html","title":"点灯工程师(LED)","keywords":"","body":"点亮 LED 点灯程序作为学习所有开发板的第一个程序，就像学所有编程语言都是先学 hello world 一样，具有着神圣的意义 众所周知， 点亮一个 LED 需要一个电源， 一个电阻， 一个 LED 灯泡， 在 Dan Dock 开发板上， 有三个 LED， 线路如下： 比如我们希望红灯点亮， 即 LED_R 连接的这个 LED， 图中可以看到 LED 的正极已经连接了 3.3V 电源， 所以我们只要让 LED_R 为低电平 LED 即可点亮。 在写程序前，我们需要知道， MaixPy 所使用的硬件 K210 的片上外设（比如GPIO、I2C等）对应的引脚是可以任意设置的，STM32 片上外设和引脚对应关系已经固定了， 只有部分引脚可以复用， 相比之下 K210 自由度更大。 比如 I2C 可以使用 Pin11 和 Pin12, 也可以改成其它任意引脚 我们控制 LED 需要使用到 GPIO 程序如下： from fpioa_manager import * from Maix import GPIO fm.register(board_info.LED_R, fm.fpioa.GPIO0) led_r=GPIO(GPIO.GPIO0,GPIO.OUT) led_r.value(0) 我们只需要将这些代码一行行依次敲到终端里面键盘按确认来执行即可 其中， 我们先从包 Maix 导入了 GPIO 这个类； 前面说了　Ｋ210 的引脚可以任意设置，　所以我们使用fm(fpioa manager)这个内置的对象来注册芯片的外设和引脚的对应关系，　这里　fm.fpioa.GPIO0 是　Ｋ210 的一个 GPIO 外设（注意区分 GPIO（外设） 和引脚（实实在在的硬件引脚）的区别 ）， 所以把 fm.fpioa.GPIO0 注册到了 引脚 board_info.LED_R； 这里的 board_info 是一个板子信息的类， 可以在串口终端输入 board_info. 然后按 TAB 按键可以看到所有成员，主要是各个引脚值 然后定义一个 GPIO 对象， 具体参数看 GPIO 模块的文档， 在左边侧边栏查找。 使用 led_r.value(0) 或者 led_r.value(1) 来设置高低电平即可 到这里已经可以点灯了， 如果了解 Python 语法的小伙伴可以尝试 写个 for 循环来实现 LED 闪烁～ "},"get_started/edit_file.html":{"url":"get_started/edit_file.html","title":"编辑并运行文件","keywords":"","body":"编辑并执行文件 MaixPy 内置了文件系统 支持 Flash 使用的 SPIFFS（目前不支持创建目录）， 默认分配了 3MB 给 SPIFF（从flash 0xD00000地址开始 3M）， 开机自动挂在到 /flash 目录下 也支持 FAT 格式的 SD （TF）卡 ，开机自动挂在到 /sd 目录下 需要注意的是， 根目录只是用来挂载 Flash 或者 SD 卡， 具体的文件在 /flash 或者 /sd 目录下 为什么需要编辑并执行文件 在前面 点亮 LED 的实验中，我们直接在终端里面敲代码来一句一句执行，这样也简单方便，我们输入命令后会立即执行并及时得到返回的结果，这种交互方式称为 REPL（Read Eval Print Loop：交互式解释器）, 这种方式的好处就是简单方便，使用起来和 Linux 终端十分相似，只是使用的语法换成了 MaixPy（Micropython） 的语法。 但实际大多数情况下我们更想将脚本写到文件中，然后执行文件，这样我们不用每次都敲代码，减少了很多麻烦 编辑并保存文件 方法一： 使用内置编辑器 Micropython Editor(pye) 在 MaixPy 中， 我们内置了一款编开源编辑器 Micropython Editor(pye) 使用 os.listdir() 可以查看当前目录下的文件， 使用 pye(\"hello.py\") 可以创建文件并进入编辑模式， 快捷键等使用说明可以在这里查看 比如我们写入代码 print(\"hello maixpy\") 然后按 Ctrl+S 按 Enter 键保存， 按 Ctrl+Q 退出编辑 注意： 使用这款编辑器对使用的串口工具有一定要求， 必须将 BackSpace 按键设置为 DEL 功能， 否则按 BackSpace 调用的是 Ctrl+H 一样的功能（即字符替换）。 Linux 下推荐使用 minicom， 需要使用 sudo minicom -s 来设置，参考前面的教程 Windows 下也一样， 根据自己使用的工具上网搜设置方法， 比如 xshell 搜 xshell如何设置backspace为del 得到结果： 文件→属性→终端→键盘， 把delete和backspace序列改为 ASCII 127即可。 方法二： 使用 MaixPy IDE 打开 MaixPy IDE， 连接开发板 编辑文件，然后在顶端Tool（工具）菜单中，点击将打开的文件保存为 boot.py 来将代码保存到开发板的boot.py文件，中，下次开发板开机上电会自动执行这个文件 当然也可以使用顶端Tool(工具)菜单中的发送文件功能来发送文件，会保存到开发板并且文件名和电脑上的文件名相同 方法三： 使用工具 uPyLoader 读取到 PC（电脑） 上编辑后再保存到开发板 下载可执行文件:release 选择串口并点击 Connect 按钮来连接板子 第一次运行该软件需要初始化， 点击 File->Init transfer files 来完成初始化，这会在板子里创建两个文件，分别是 __upload.py 和 __download.py。 然后双机文件名即可打开文件并编辑，编辑完成后点击 save 来保存到开发板即可 方法四： 使用工具 rshell 读取到 PC（电脑） 上编辑后再保存到开发板 按照 rshell 项目主页的说明安装好 rshell sudo apt-get install python3-pip sudo pip3 install rshell rshell -p /dev/ttyUSB1 # 这里根据实际情况选择串口 编辑文件 ls /flash edit /flash/boot.py # 编辑器使用方法和 vim 一样 执行文件 使用 os.chdir() 切换当前目录到文件的目录，比如 os.chdir(\"/flash\") 方法一： import 然后执行 import hello 即可看到输出 hello maixpy 使用此方法简单易用，但是需要注意的是， 目前 import 只能使用一次， 如果第二次 import， 则文件不会再执行， 如果需要多次执行，建议使用下面的方法 方法二： exec() 使用 exec() 函数来执行 with open(\"hello.py\") as f: exec(f.read()) 方法三： 使用 MaixPy IDE 来执行 打开文件， 然后点击执行按钮来执行 方法四： 使用 uPyLoader 来执行 连接好后选中文件， 点击 excute 按钮来执行文件 方法五： 使用 ampy 来直接运行电脑上的文件 ampy 执行命令 ampy run file_in_PC.py 来执行位于电脑上的文件（文件不会保存到开发板） "},"get_started/upload_script.html":{"url":"get_started/upload_script.html","title":"上传脚本到开发板","keywords":"","body":"上传脚本到开发板 前面我们接触到了直接执行 pye(\"filename.py\") 命令可以打开一个编辑器，可以直接编辑文件系统中的文件 但是慢慢我们会发现，这样的方法只适合用来改少量的代码，当代码量庞大或者我们需要高亮支持时，它就不适用了，我们需要在电脑上写完代码，然后上传到板子的文件系统里面 目前有以下几种方法： 使用 MaixPy IDE 上传脚本到开发板 打开 MaixPy IDE， 连接开发板 编辑文件，然后在顶端Tool（工具）菜单中，点击将打开的文件保存为 boot.py 来将代码保存到开发板的boot.py文件，中，下次开发板开机上电会自动执行这个文件 当然也可以使用顶端Tool(工具)菜单中的发送文件功能来发送文件，会保存到开发板并且文件名和电脑上的文件名相同，（除了脚本也可以上传其它文件，不要太大） 使用图形工具 uPyLoader 上传、运行脚本 uPyLoader 是一款开源软件，使用它可以方便地连接 MaixPy 并且上传、下载、执行文件，同时监控输出等等功能，功能比较完善 下载可执行文件:release 选择串口并点击 Connect 按钮来连接板子 第一次运行该软件需要初始化， 点击 File->Init transfer files 来完成初始化，这会在板子里创建两个文件，分别是 __upload.py 和 __download.py。 左边选中需要上传的文件，点击 Transfer 即可上传到板子的文件系统。 右边是板子里面的文件， 点击 List files 可以刷新文件列表， 选中 文件名， 点击 Execute 即可执行该脚本文件 点击上面的 View -> terminal 可以打开终端 用来查看运行时的输出或者发送命令 使用工具 rshell 正如使用 linux 终端一样， 使用 rshell 的 cp 命令即可简单地复制文件到开发板 按照 rshell 项目主页的说明安装好 rshell sudo apt-get install python3-pip sudo pip3 install rshell rshell -p /dev/ttyUSB1 # 这里根据实际情况选择串口 ls /flash cp ./test.py /flash/ #复制电脑当前目录的文件 test.py 到开发板 flash 根目录 当然， 还有其它更多功能， 详情请访问其 项目主页 使用命令行工具 ampy ampy 是一个简单易用的命令行上传、下载、执行文件 的工具， 而且开源 注意这个工具是运行在电脑端的，而不是运行在板子上的 使用 ampy --help 来查看帮助信息 使用 ampy run file_in_PC.py 命令还可以不上传脚本到板子而是直接在板子上运行该脚本 TF 卡拷贝 拷贝到 TF 卡后， 在终端中执行 import 文件名 来运行脚本 "},"get_started/boot.html":{"url":"get_started/boot.html","title":"开机自动运行脚本","keywords":"","body":"开机自启动脚本 系统会在 /flash 或者 /sd 目录创建 boot.py 文件， 开机会自动先执行这个脚本， 编辑这个脚本的内容即可实现开机自启 "},"get_started/how_to_read.html":{"url":"get_started/how_to_read.html","title":"如何正确阅读本文档","keywords":"","body":"如何正确使用（/阅读）本文 首先请仔细阅读一遍左边侧边栏的目录结构看一看文档有那些内容 刚接触，可以根据左边侧边栏的目录从上到下一页一页仔细看，跟着做即可。 然后学会如何更新固件，如何写代码 每个模块/库文档里面的结尾都附有简单例程， 或者到这里查找需要的示例， 可以尝试运行看效果 最后关于模块的接口及参数，在使用时根据自己的需求进行查阅，左上角有搜索框，可以好好利用，同时也可以使用浏览器的页面搜索功能，即按键盘Ctrl+F，然后输入要搜索的内容后按确认键 如果有找不到的内容也请不要着急， 可以上 github 的 issue） 页面找一找（/搜一搜）是不是有人提过了，没有的话可以新建 issue ， 或者到 论坛 向大家求助， 或者联系技术支持。 如果网页加载比较慢， 请尝试刷新或者等待， 或者换个线路 文档使用 gitbook 从 markdown 自动生成为静态页面， 如果遇到有些页面无法访问， 请检查一下网址（路径）是否正确， 可以回到首页 (maixpy.sipeed.com) 重新进入即可。 比如这个网址就是由于点击过快导致的： http://localhost:4000/zh/zh/get_started/how_to_read.html 正确的网址应该是： http://localhost:4000/zh/get_started/how_to_read.html "},"libs/standard/":{"url":"libs/standard/","title":"标准库","keywords":"","body":"标准库 cmath gc math sys ubinascii ucollections uctypes uerrno uheapq ujson uos ure uselect usocket ustruct utime uzlib "},"libs/standard/cmath.html":{"url":"libs/standard/cmath.html","title":"cmath","keywords":"","body":"cmath – 复数的数学函数 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档： cmath. cmath模块提供了一些处理复数的基本数学函数。 函数 cos cmath.cos(z) 返回z的余弦。 exp cmath.exp(z) 返回z的指数。 log cmath.log(z) 返回z的自然对数。分支切割沿负实轴。 log10 cmath.log10(z) 返回z的以10为底的对数。分支切割沿负实轴。 phase cmath.phase(z) 返回数字“z”的相位，范围（-pi，+ pi）。 polar cmath.polar(z) 作为元组返回z的极性形式。 rect cmath.rect(r, phi) 返回模数r和相位phi的复数。 sin cmath.sin(z) 返回z的正弦值。 sqrt cmath.sqrt(z) 返回z的平方根。 Constants cmath.e 自然对数的基础 cmath.pi 圆周长与直径的比值 "},"libs/standard/gc.html":{"url":"libs/standard/gc.html","title":"gc","keywords":"","body":"gc – 控制垃圾收集器 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档：gc. 函数 gc.enable() 启用自动垃圾回收。 gc.disable() 禁用自动垃圾回收。仍然可以分配堆内存，仍然可以使用 gc.collect() 手动启动垃圾收集。 gc.collect() 运行垃圾回收。 gc.mem_alloc() 返回分配的堆RAM的字节数。 Difference to CPython 此功能是MicroPython扩展。 gc.mem_free() 返回可用堆RAM的字节数，如果堆剩余数量未知，则返回-1。 与CPython的区别 此功能是MicroPython扩展。 gc.threshold([amount]) 设置或查询其他GC分配阈值。通常，仅当不能满足新分配时，即在内存不足（OOM）条件下才触发集合。如果调用此函数，除了OOM之外，每次分配了大量字节后都会触发一个集合（总共，因为上一次分配了这么多的字节）。 amount通常被指定为小于完整堆大小，意图在堆耗尽之前触发集合，并希望早期集合可以防止过多的内存碎片。这是一种启发式度量，其效果因应用程序而异，以及量参数的最佳值。 不带参数调用函数将返回阈值的当前值。值-1表示禁用的分配阈值。 与CPython的区别 此函数是MicroPython扩展。 CPython有一个类似的函数 - set_threshold()，但是由于不同的GC实现，它的签名和语义是不同的。 "},"libs/standard/math.html":{"url":"libs/standard/math.html","title":"math","keywords":"","body":"math – 数学函数 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档：math. math模块提供了一些处理浮点数的基本数学函数。 函数 math.acos(x) 返回x的反余弦值。 math.acosh(x) 返回x的反双曲余弦值。 math.asin(x) 返回x的反正弦。 math.asinh(x) 返回x的反双曲正弦值。 math.atan(x) 返回x的反正切。 math.atan2(y, x) 返回y /x的反正切的主值。 math.atanh(x) 返回x的反双曲正切。 math.ceil(x) 返回一个整数，“x”向正无穷大四舍五入。 math.copysign(x, y) 以y的符号返回x。 math.cos(x) 返回x的余弦。 math.cosh(x) 返回x的双曲余弦值 math.degrees(x) 返回弧度x转换为度数。 math.erf(x) 返回x的错误函数。 math.erfc(x) 返回x的互补误差函数。 math.exp(x) 返回x的指数。 math.expm1(x) 返回exp（x） - 1。 math.fabs(x) 返回x的绝对值。 math.floor(x) 返回一个整数，“x”向负无穷大舍入。 math.fmod(x, y) 返回x /y的余数。 math.frexp(x) 将浮点数分解为尾数和指数。返回的值是元组（m，e），使得x == m * 2 ** e完全正确。如果x == 0则函数返回（0.0,0），否则关系0.5 成立。 math.gamma(x) 返回x的伽玛函数。 math.isfinite(x) 如果x是有限的，则返回True。 math.isinf(x) 如果x是无限的，则返回True。 math.isnan(x) 如果x不是数字，则返回True math.ldexp(x, exp) 返回x *（2 ** exp）。 math.lgamma(x) 返回x的伽玛函数的自然对数。 math.log(x) 返回x的自然对数。 math.log10(x) 返回x的以10为底的对数。 math.log2(x) 返回x的base-2对数。 math.modf(x) 返回两个浮点数的元组，是“x”的分数和整数部分。两个返回值都与x具有相同的符号。 math.pow(x, y) 将x返回到'y`的幂。 math.radians(x) 返回度数x转换为弧度。 math.sin(x) 返回x的正弦值。 math.sinh(x) 返回x的双曲正弦值。 math.sqrt(x) 返回x的平方根。 math.tan(x) 返回x的正切值。 math.tanh(x) 返回x的双曲正切。 math.trunc(x) 返回一个整数，“x”向0舍入。 Constants math.e 自然对数的基础 math.pi 圆周长与直径的比值 "},"libs/standard/sys.html":{"url":"libs/standard/sys.html","title":"sys","keywords":"","body":"sys – 系统特定功能 该模块实现了相应CPython模块的子集，如下所述。 有关更多信息，请参阅原始CPython文档：sys. 功能函数 sys.exit(retval=0) 使用给定的退出代码终止当前程序。 根据此，此函数引发“SystemExit”异常。 如果给出了一个参数，它的值作为SystemExit的参数给出。 sys.print_exception(exc, file=sys.stdout) 使用回溯到类文件对象文件（或默认情况下为sys.stdout）打印异常。 和 CPython 的不同 这是一个函数的简化版本，它出现在CPython的回溯模块中。 与traceback.print_exception（）不同，此函数只接受异常值而不是异常类型，异常值和回溯对象; file参数应该是位置的; 不支持其他参数。 可以在micropython-lib中找到与CPython兼容的回溯模块。 常量 sys.argv 当前程序启动时的可变参数列表。 sys.byteorder 系统的字节顺序（“小端”或“大端”`）。 sys.implementation 包含有关当前Python实现的信息的对象。 对于MicroPython，它具有以下属性： name - 字符串“micropython” version - 元组 (major, minor, micro), e.g. (1, 7, 0) 此对象是区分MicroPython与其他Python实现的推荐方法（请注意，它仍然可能不存在于非常小的端口中）。 和 CPython 的不同 CPython要求为此对象提供更多属性，但实际有用的最低要求是在MicroPython中实现的。 sys.maxsize 本机整数类型可以在当前平台上保存的最大值，或MicroPython整数类型可表示的最大值，如果它小于平台最大值（对于没有长int支持的MicroPython端口的情况）。 此属性对于检测平台的“位数”（32位与64位等）非常有用。 建议不要直接将此属性与某个值进行比较，而是计算其中的位数： bits = 0 v = sys.maxsize while v: bits += 1 v >>= 1 if bits > 32: # 64-bit (or more) platform ... else: # 32-bit (or less) platform # Note that on 32-bit platform, value of bits may be less than 32 # (e.g. 31) due to peculiarities described above, so use \"> 16\", # \"> 32\", \"> 64\" style of comparisons. sys.modules 加载模块的字典。 在某些端口上，它可能不包含内置模块。 sys.path 用于搜索导入模块的可变目录列表。 sys.platform 运行 MicroPython 的平台。 对于OS / RTOS端口，这通常是OS的标识符，例如，“LINUX”。 对于裸金属端口，它是电路板的标识符，例如 “pyboard”用于原始的 MicroPython 参考板。 因此，它可用于区分一块板与另一块板。 如果您需要检查您的程序是否在 MicroPython 上运行（与其他 Python 实现相比），请使用sys.implementation。 sys.stderr 标准错误 stream. sys.stdin 标准输入 stream. sys.stdout 标准输出 stream. sys.version 实现的 Python 版本， 返回一个字符串 sys.version_info 实现的 Python 版本， 返回一个由整数组成的元组 "},"libs/standard/ubinascii.html":{"url":"libs/standard/ubinascii.html","title":"ubinascii","keywords":"","body":"ubinascii – 二进制/ ASCII转换 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档：binascii. 该模块以ASCII格式（两个方向）实现二进制数据与其各种编码之间的转换。 函数 ubinascii.hexlify(data[, sep]) 将二进制数据转换为十六进制表示。返回字节字符串。 与CPython的区别 如果提供了附加参数sep，则它将用作十六进制值之间的分隔符。 ubinascii.unhexlify(data) 将十六进制数据转换为二进制表示。返回字节字符串。 （即hexlify的倒数） ubinascii.a2b_base64(data) 解码base64编码的数据，忽略输入中的无效字符。符合 RFC 2045 s.6.8. 返回一个bytes对象。 ubinascii.b2a_base64(data) 以base64格式编码二进制数据，如 RFC 3548所述。返回编码数据，后跟换行符，作为bytes对象。 "},"libs/standard/ucollections.html":{"url":"libs/standard/ucollections.html","title":"ucollections","keywords":"","body":"ucollections – 集合和容器类型 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档 collections. 此模块实现高级集合和容器类型以保存/累积各种对象。 类 ucollections.deque(iterable, maxlen[, flags]) Deques（双端队列）是一个类似列表的容器，支持O（1）追加并从双端队列的任一侧弹出。使用以下参数创建新的deques： iterable必须是空元组，并且新的deque被创建为空。 必须指定maxlen，并且双端队列将限制为此最大长度。一旦双端队列已满，添加的任何新项目将丢弃对方的项目。 添加项目时，可选标志可以为1以检查溢出。 除了支持bool和len之外，deque对象还有以下方法： deque.append(x) 将x添加到双端队列的右侧。如果启用了溢出检查并且没有剩余空间，则引发 IndexError。 deque.popleft() 从双端队列的左侧移除并返回一个项目。如果没有项目，则引发 IndexError。 ucollections.namedtuple(name, fields) 这是工厂函数，用于创建具有特定名称和字段集的新的namedtuple类型。 namedtuple是元组的子类，它不仅可以通过数字索引访问其字段，还可以使用符号字段名称访问属性访问语法。 Fields是指定字段名称的字符串序列。为了与CPython兼容，它也可以是一个以空格分隔的字段命名的字符串（但效率较低）。使用示例： from ucollections import namedtuple MyTuple = namedtuple(\"MyTuple\", (\"id\", \"name\")) t1 = MyTuple(1, \"foo\") t2 = MyTuple(2, \"bar\") print(t1.name) assert t2.name == t2[1] ucollections.OrderedDict(...) dict类型子类，它记住并保留添加的键的顺序。当迭代命令dict时，按照添加的顺序返回键/项： from ucollections import OrderedDict # To make benefit of ordered keys, OrderedDict should be initialized # from sequence of (key, value) pairs. d = OrderedDict([(\"z\", 1), (\"a\", 2)]) # More items can be added as usual d[\"w\"] = 5 d[\"b\"] = 3 for k, v in d.items(): print(k, v) Output: z 1 a 2 w 5 b 3 "},"libs/standard/uctypes.html":{"url":"libs/standard/uctypes.html","title":"uctypes","keywords":"","body":"uctypes – 以结构化方式访问二进制数据 该模块为MicroPython实现“外部数据接口”。 它背后的想法类似于CPython的ctypes模块，但实际的API是不同的，流线型和小尺寸优化。 该模块的基本思想是定义具有与C语言允许的功能大致相同的数据的数据结构布局，然后使用熟悉的点语法访问它以引用子字段。 警告 uctypes模块允许访问机器的任意内存地址（包括I / O和控制寄存器）。 不小心使用它可能会导致崩溃，数据丢失，甚至硬件故障。 也可参考 ustruct模块 用于访问二进制数据结构的标准Python方法（不能很好地扩展到大型和复杂的结构）。 例程： import uctypes # Example 1: Subset of ELF file header # https://wikipedia.org/wiki/Executable_and_Linkable_Format#File_header ELF_HEADER = { \"EI_MAG\": (0x0 | uctypes.ARRAY, 4 | uctypes.UINT8), \"EI_DATA\": 0x5 | uctypes.UINT8, \"e_machine\": 0x12 | uctypes.UINT16, } # \"f\" is an ELF file opened in binary mode buf = f.read(uctypes.sizeof(ELF_HEADER, uctypes.LITTLE_ENDIAN)) header = uctypes.struct(uctypes.addressof(buf), ELF_HEADER, uctypes.LITTLE_ENDIAN) assert header.EI_MAG == b\"\\x7fELF\" assert header.EI_DATA == 1, \"Oops, wrong endianness. Could retry with uctypes.BIG_ENDIAN.\" print(\"machine:\", hex(header.e_machine)) # Example 2: In-memory data structure, with pointers COORD = { \"x\": 0 | uctypes.FLOAT32, \"y\": 4 | uctypes.FLOAT32, } STRUCT1 = { \"data1\": 0 | uctypes.UINT8, \"data2\": 4 | uctypes.UINT32, \"ptr\": (8 | uctypes.PTR, COORD), } # Suppose you have address of a structure of type STRUCT1 in \"addr\" # uctypes.NATIVE is optional (used by default) struct1 = uctypes.struct(addr, STRUCT1, uctypes.NATIVE) print(\"x:\", struct1.ptr[0].x) # Example 3: Access to CPU registers. Subset of STM32F4xx WWDG block WWDG_LAYOUT = { \"WWDG_CR\": (0, { # BFUINT32 here means size of the WWDG_CR register \"WDGA\": 7 定义结构布局 结构布局由“描述符”定义 - 一个Python字典，它将字段名称编码为键，以及将它们作为关联值访问它们所需的其他属性： { \"field1\": , \"field2\": , ... } 目前，uctypes需要明确规定每个字段的偏移量。 从结构开始以字节为单位给出偏移量。 以下是各种字段类型的编码示例： 标量类型: \"field_name\": offset | uctypes.UINT32 换句话说，该值是标量类型标识符，与结构起始处的字段偏移量（以字节为单位）进行或运算。 递归结构： \"sub\": (offset, { \"b0\": 0 | uctypes.UINT8, \"b1\": 1 | uctypes.UINT8, }) 即，值是2元组，其第一个元素是偏移量，第二个是结构描述符字典（注意：递归描述符中的偏移量与其定义的结构相关）。 当然，递归结构不仅可以通过文字字典指定，还可以通过按名称引用结构描述符字典（前面定义）来指定。 原始类型的数组： \"arr\": (offset | uctypes.ARRAY, size | uctypes.UINT8), 即，值是一个2元组，其第一个元素是ARRAY标志与偏移进行OR运算，第二个是标量元素类型ORed数组中的元素数。 *聚合类型数组： \"arr2\": (offset | uctypes.ARRAY, size, {\"b\": 0 | uctypes.UINT8}), 即，值是一个3元组，其第一个元素是ARRAY标志，与偏移相关，第二个是数组中的元素数，第三个是元素类型的描述符。 *指向原始类型的指针： \"ptr\": (offset | uctypes.PTR, uctypes.UINT8), 即，值是2元组，其第一个元素是PTR标志与偏移进行OR运算，第二个元素是标量元素类型。 *指向聚合类型的指针： \"ptr2\": (offset | uctypes.PTR, {\"b\": 0 | uctypes.UINT8}), 即，值是2元组，其第一个元素是PTR标志与偏移量进行OR运算，第二个元素是指向的类型的描述符。 *比特场： \"bitf0\": offset | uctypes.BFUINT16 | lsbit 即，value是一种包含给定位域的标量值（类型名称类似于标量类型，但前缀为“BF”），与包含位域的标量值的偏移进行OR运算，并进一步与位位置和位长度的值进行“或”运算。标量值内的位域，分别移位BF_POS和BF_LEN位。位域位置从标量的最低有效位（具有0的位置）开始计数，并且是字段的最右位的数量（换句话说，它是标量需要向右移位的位数）提取位域）。 在上面的例子中，首先在偏移0处提取UINT16值（当访问硬件寄存器时，这个细节可能很重要，需要特定的访问大小和对齐），然后是最右边的位是此UINT16的lsbit位的位域，以及length是bitsize bits，将被提取。例如，如果lsbit为0且bitsize为8，那么它将有效地访问UINT16的最低有效字节。 注意，位域操作独立于目标字节字节序，特别是上面的例子将在小端和大端结构中访问UINT16的最低有效字节。但它取决于最低有效位被编号为0.某些目标可能在其原生ABI中使用不同的编号，但是“uctypes”总是使用上述的标准化编号。 模块内容 class uctypes.struct(addr, descriptor, layout_type=NATIVE) 基于内存中的结构地址，描述符（编码为字典）和布局类型（参见下文）来实例化“外部数据结构”对象。 uctypes.LITTLE_ENDIAN little-endian压缩结构的布局类型。 （打包意味着每个字段占用描述符中定义的字节数，即对齐为1）。 uctypes.BIG_ENDIAN big-endian压缩结构的布局类型。 uctypes.NATIVE 本机结构的布局类型 - 数据字节顺序和对齐符合运行MicroPython的系统的ABI。 uctypes.sizeof(struct, layout_type=NATIVE) 以字节为单位返回数据结构的大小。 struct参数可以是结构类，也可以是特定的实例化结构对象（或其聚合字段）。 uctypes.addressof(obj) 返回对象的地址。 参数应该是字节，字节数组或其他支持缓冲区协议的对象（该缓冲区的地址实际上是返回的）。 uctypes.bytes_at(addr, size) 以给定的地址和大小捕获内存作为bytes对象。 由于bytes对象是不可变的，因此内存实际上是复制并复制到bytes对象中，因此如果内存内容稍后更改，则创建的对象将保留原始值。 uctypes.bytearray_at(addr, size) 将给定地址和大小的内存捕获为bytearray对象。 与上面的bytes_at（）函数不同，内存是通过引用捕获的，因此它也可以写入，并且您将在给定的内存地址访问当前值。 uctypes.UINT8 uctypes.INT8 uctypes.UINT16 uctypes.INT16 uctypes.UINT32 uctypes.INT32 uctypes.UINT64 uctypes.INT64 结构描述符的整数类型。 提供了8,16,32和64位类型的常量，包括有符号和无符号。 uctypes.FLOAT32 uctypes.FLOAT64 结构描述符的浮点类型。 uctypes.VOID VOID是UINT8的别名，用于方便地定义C的void指针：（uctypes.PTR，uctypes.VOID）。 uctypes.PTR uctypes.ARRAY 输入指针和数组的常量。 请注意，结构没有显式常量，它是隐式的：没有PTR或ARRAY标志的聚合类型是一种结构。 结构描述符和实例化结构对象 给定结构描述符字典及其布局类型，您可以使用uctypes.struct（）构造函数在给定的内存地址实例化特定的结构实例。 内存地址通常来自以下来源： *访问裸机系统上的硬件寄存器时的预定义地址。 在特定MCU / SoC的数据表中查找这些地址。 *作为调用某些FFI（外部函数接口）函数的返回值。 *来自uctypes.addressof（），当您想要将参数传递给FFI函数时，或者访问I / O的某些数据（例如，从文件或网络套接字读取的数据）。 结构对象 结构对象允许使用标准点表示法访问单个字段：`my_struct.substruct1.field1。如果字段是标量类型，获取它将产生与字段中包含的值对应的原始值（Python整数或浮点数）。 标量字段也可以分配给。 如果某个字段是一个数组，则可以使用标准的下标运算符[]访问其各个元素 - 同时读取和分配。 如果一个字段是一个指针，它可以使用[0]语法解除引用（对应于C *运算符，尽管[0]也适用于C）。 还支持使用其他整数值（但是为0）订阅指针，其语义与C中相同。 总而言之，访问结构字段通常遵循C语法，除了指针取消引用，当您需要使用[0]运算符而不是*时。 限制 访问非标量字段会导致分配中间对象以表示它们。这意味着应该特别注意布局在禁用内存分配时（例如从中断）需要访问的结构。建议如下： 避免访问嵌套结构。例如，代替mcu_registers.peripheral_a.register1，为每个外设定义单独的布局描述符，作为peripheral_a.register1进行访问。或者只缓存特定的外设：peripheral_a = mcu_registers.peripheral_a。如果寄存器由多个位域组成，则需要缓存对特定寄存器的引用：reg_a = mcu_registers.peripheral_a.reg_a。 避免使用其他非标量数据，如数组。例如，使用peripheral_a.register0而不是peripheral_a.register [0]。同样，另一种方法是缓存中间值，例如register0 = peripheral_a.register [0]。 uctypes模块支持的偏移范围是有限的。支持的确切范围被认为是实现细节，一般建议是将结构定义拆分为从几千字节到几十千字节的最大值。在大多数情况下，这是一种自然情况，例如，在一个结构中定义MCU的所有寄存器（扩展到32位地址空间）没有意义，而是通过外设块定义外设块。在某些极端情况下，您可能需要人工分割几个部分的结构（例如，如果在中间访问具有多兆字节数组的本机数据结构，尽管这将是非常合成的情况）。） "},"libs/standard/uerrno.html":{"url":"libs/standard/uerrno.html","title":"uerrno","keywords":"","body":"uerrno — 系统错误代码 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档：errno。 该模块描述了 OSError 错误的错误标识。特定的代码库存取决于 Micropython 的移植， 错误会在特定的会出现错误的函数进行说明。 常量 EEXIST, EAGAIN, 等 基于 ANSI C / POSIX 标准的错误代码。所有错误代码均以 “E” 开头。如上所述，代码库存取决于 MicroPython 的移植。错误通常可以作为exc.args [0]访问，其中exc是OSError的一个实例。用法示例： try: uos.mkdir(\"my_dir\") except OSError as exc: if exc.args[0] == uerrno.EEXIST: print(\"Directory already exists\") uerrno.errorcode 字典将数字错误代码映射到带有符号错误代码的字符串（参见上文）： >>> print(uerrno.errorcode[uerrno.EEXIST]) EEXIST "},"libs/standard/uheapq.html":{"url":"libs/standard/uheapq.html","title":"uheapq","keywords":"","body":"uheapq – 堆队列算法 该模块实现了对应 CPython 模块的子集，如下所述。 有关更多信息，请参阅原始CPython文档：heapq。 该模块实现堆队列算法。 堆队列只是一个以某种方式存储其元素的列表。 函数 heappush uheapq.heappush(heap, item) 将元素放入堆。 heappop uheapq.heappop(heap) 弹出堆中的第一个元素，然后将其返回。 如果heap为空，则引发IndexError。 heapify uheapq.heapify(x) 将列表x转换为堆。 这是一个 in-place（划分交换排序）操作。 "},"libs/standard/ujson.html":{"url":"libs/standard/ujson.html","title":"ujson","keywords":"","body":"ujson – JSON encoding and decoding 该模块实现了相应 CPython 模块的子集，如下所述。有关更多信息，请参阅原始 CPython 文档：json. 此模块允许在 Python 对象和 JSON 数据格式之间进行转换。 函数 dump ujson.dump(obj, stream) 将 obj 序列化化为 JSON 字符串，将其写入给定的流。 dumps ujson.dumps(obj) 返回表示为 JSON 字符串的 obj。 load ujson.load(stream) 解析给定的流，将其解释为 JSON 字符串并将数据反序列化为 Python 对象。返回结果对象。 解析继续，直到遇到文件结尾。如果未正确形成流中的数据，则会引发 ValueError。 loads ujson.loads(str) 解析JSON str并返回一个对象。如果字符串格式出错，则引发ValueError。 "},"libs/standard/uos.html":{"url":"libs/standard/uos.html","title":"uos","keywords":"","body":"uos – 基本的“操作系统”服务 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档：os。 uos模块包含用于文件系统访问和挂载，终端重定向和复制以及uname和urandom等函数。 常用函数 uos.uname() 返回一个元组（可能是一个命名了的元组），其中包含有关底层机器和/或其操作系统的信息。元组按以下顺序有五个字段，每个字段都是一个字符串： sysname - 底层系统的名称 nodename - 节点名（/板子名称）（可以与sysname相同） release - 底层系统的版本 version - MicroPython版本和构建日期 machine - 底层硬件的标识符（例如，板，CPU） uos.urandom(n) 返回一个包含n个随机字节的字节对象。只要有可能，它就由硬件随机数生成器生成。 文件系统访问 uos.chdir(path) 更改当前目录。 uos.getcwd() 获取当前目录。 uos.ilistdir([dir]) 此函数返回一个迭代器，然后生成与列出的目录中的条目对应的元组。如果不传参数，它列出了当前目录，否则它列出了dir给出的目录。 元组具有形式（名称，类型，inode [，大小]）： name： 是一个字符串（如果dir是一个字节对象，则为字节），并且是条目的名称; type： 是一个整数，指定条目的类型，目录为 0x4000，常规文件为 0x8000; inode： 是对应于文件inode的整数，对于没有这种概念的文件系统可以是0。 某些平台可能会返回包含条目大小的4元组。对于文件条目，size是表示文件大小的整数，如果未知则为-1。目前条目的含义目前尚未定义。 uos.listdir([dir]) 如果没有参数，请列出当前目录。否则列出给定目录。 uos.mkdir(path) 创建一个新目录。 uos.remove(path) 删除文件。 uos.rmdir(path) 删除目录。 uos.rename（old_path，new_path） 重命名文件。 uos.stat(path) 获取文件或目录的状态。 uos.statvfs(path) 获取文件系统的状态。 按以下顺序返回包含文件系统信息的元组： f_bsize - 文件系统块大小 f_frsize - 片段大小 f_blocks - f_frsize单位中fs的大小 f_bfree - 空闲块数 f_bavail - 无特权用户的空闲块数 f_files - inode数量 f_ffree - 免费inode的数量 f_favail - 无特权用户的免费inode数 f_flag - 挂载标志 f_namemax - 最大文件名长度 与inode相关的参数：f_files，f_ffree，f_avail和f_flags参数可能返回'0`，因为它们在特定于硬件的实现中不可用。 uos.sync() 同步所有文件系统。 终端重定向和复制 uos.dupterm(stream_object，index = 0) 在给定的stream类对象上复制或切换MicroPython终端（REPL）。 stream_object参数必须实现readinto（）和write（）方法。流应处于非阻塞模式，如果没有可用于读取的数据，readinto（）应返回'None`。 调用此函数后，将在此流上重复所有终端输出，并且流上可用的任何输入都将传递到终端输入。 index参数应为非负整数，并指定设置的复制槽。给定端口可以实现多个槽（槽0将始终可用），并且在这种情况下，终端输入和输出在所有设置的槽上复制。 如果None作为stream_object传递，则在索引给出的槽上取消复制。 该函数返回给定槽中的前一个类似流的对象。 文件系统挂载 某些端口提供虚拟文件系统（VFS）以及在此VFS中安装多个“真实”文件系统的功能。文件系统对象可以安装在VFS的根目录中，也可以安装在根目录中的子目录中。这允许Python程序看到的文件系统的动态和灵活配置。具有此功能的端口提供mount（）和umount（）函数，以及可能由VFS类表示的各种文件系统实现。 uos.mount(fsobj，mount_point，*，readonly) 将文件系统对象fsobj挂载到mount_point字符串指定的VFS中的位置。 fsobj可以是一个具有mount（）方法或块设备的VFS对象。如果它是块设备，则会自动检测文件系统类型（如果未识别文件系统，则会引发异常）。 mount_point可以是'/'在根目录下挂载fsobj，或者'/ '挂载到根目录下的子目录中。 如果readonly为“True”，则文件系统以只读方式挂载。 在mount过程中，在文件系统对象上调用mount（）方法。 如果mount_point已经挂载，将引发OSError（EPERM）。 uos.umount(mount_point) 卸载文件系统。 mount_point可以是命名安装位置的字符串，也可以是先前安装的文件系统对象。在卸载过程中，在文件系统对象上调用方法umount（）。 如果找不到mount_point，会引发OSError（EINVAL）。 class uos.VfsFat(block_dev) 创建使用FAT文件系统格式的文件系统对象。 FAT文件系统的存储由block_dev提供。可以使用mount（）挂载由此构造函数创建的对象。 static mkfs(block_dev) 在block_dev上构建FAT文件系统。 文件系统格式化 在MaixPy中，我们提供了对flash进行文件系统格式化的操作。如果用户想要清空flash文件系统那么可以使用该接口 flash_format 来实现 uos.flash_format() 该接口不需要传入参数，直接使用将对开发板的 flash 进行格式化。请注意，格式化将清空所有文件，在使用前请确认 flash 中文件都是需要删除的 块设备 块设备是实现块协议的对象，块协议是由 AbstractBlockDev 类在下面描述的一组方法。该类的具体实现通常允许访问类似存储器的功能作为硬件（如闪存）。特定文件系统驱动程序可以使用块设备来存储其文件系统的数据。 class uos.AbstractBlockDev()...) 构造块设备对象。构造函数的参数取决于特定的块设备。 readblocks(block_num, buf) 从索引block_num给出的块开始，将块从设备读入buf（字节数组）。要读取的块数由buf的长度给出，该长度将是块大小的倍数。 writeblocks(block_num, buf) 从索引block_num给出的块开始，将buf（字节数组）中的块写入设备。要写入的块数由buf的长度给出，该长度将是块大小的倍数。 ioctl(op, arg) 控制块设备并查询其参数。要执行的操作由op给出，它是以下整数之一： 1 - 初始化设备（arg未使用） 2 - 关闭设备（arg未使用） 3 - 同步设备（arg未使用） 4 - 获取块数的计数，应该返回一个整数（arg未使用） 5 - 获取块中的字节数，应该返回一个整数，或者“None”，在这种情况下使用默认值512（arg未使用） 例程 例程1 以fat32举例，下面的类将实现一个块设备，它使用bytearray将其数据存储在RAM中： class RAMBlockDev: def __init__(self, block_size, num_blocks): self.block_size = block_size self.data = bytearray(block_size * num_blocks) def readblocks(self, block_num, buf): for i in range(len(buf)): buf[i] = self.data[block_num * self.block_size + i] def writeblocks(self, block_num, buf): for i in range(len(buf)): self.data[block_num * self.block_size + i] = buf[i] def ioctl(self, op, arg): if op == 4: # get number of blocks return len(self.data) // self.block_size if op == 5: # get block size return self.block_size 或者： import uos bdev = RAMBlockDev(512, 50) uos.VfsFat.mkfs(bdev) vfs = uos.VfsFat(bdev) uos.mount(vfs, '/ramdisk') 例程2 以spiffs举例，下面的类将实现一个块设备，它使用bytearray将其数据存储在RAM中： class RAMFlashDev: def __init__(self): self.fs_size = 256*1024 self.fs_data = bytearray(256*1024) self.erase_block = 32*1024 self.log_block_size = 64*1024 self.log_page_size = 4*1024 def read(self,buf,size,addr): for i in range(len(buf)): buf[i] = self.fs_data[addr+i] def write(self,buf,size,addr): for i in range(len(buf)): self.fs_data[addr+i] = buf[i] def erase(self,size,addr): for i in range(size): self.fs_data[addr+i] = 0xff blkdev = RAMFlashDev.RAMFlashDev() vfs = uos.VfsSpiffs(blkdev) vfs.mkfs(vfs) uos.mount(vfs,'/ramdisk') "},"libs/standard/ure.html":{"url":"libs/standard/ure.html","title":"ure","keywords":"","body":"ure – 简单的正则表达式 该模块实现了相应CPython模块的子集，如下所述。 有关更多信息，请参阅原始CPython文档：re. 该模块实现了正则表达式操作。 支持的正则表达式语法是CPythonre模块的子集（实际上是POSIX扩展正则表达式的子集）。 支持的运算符和特殊序列 . : 匹配任何字符。 [...] : 匹配字符集。 支持单个字符和范围，包括否定集（例如[^ a-c]）。 ^ : 匹配字符串的开头。 $ : 匹配字符串的结尾。 ? : 匹配零个或前一个子模式之一。 * : 匹配前一个子模式的零个或多个。 + : 匹配前一个子模式中的一个或多个。 ?? : 非贪婪版的？，匹配零或一，偏好为零。 *? : *的非贪婪版本，匹配零或更多，优先选择最短匹配。 +? : 非贪婪的“+”版本，匹配一个或多个，优先匹配最短。 | : 匹配此运算符的左侧或右侧子模式。 (...) : 分组。 每个组都在捕获（它捕获的子字符串可以使用`match.group（）方法访问）。 \\d : 匹配数字。 相当于[0-9]。 \\D : 匹配非数字。 相当于[^ 0-9]。 \\s : \\S : 匹配空白。 相当于 [^ \\t-\\r]. \\w : 匹配“单词字符”（仅限ASCII）。 相当于 [A-Za-z0-9_]. \\W : 匹配非“单词字符”（仅限ASCII）。 相当于 [^A-Za-z0-9_]. \\ : 转义字符。 除了上面列出的那些之外，反斜杠后面的任何其他字符都是字面意思。 例如，\\*等同于文字*（不被视为*运算符）。 请注意，\\r，\\n，等不是专门处理的，并且相当于文字字母r，n等。因此，不建议使用原始Python字符串（r“”）用于正则表达式。 例如，r“\\r \\n”用作正则表达式时相当于“rn”。 要匹配CR后跟LF的字符，请使用\"\\r\\n\"。 不支持的表达式 重复计算 ({m,n}) 命名组 ((?P...)) 非捕获组 ((?:...)) 更高级的断言 (\\b, \\B) 像\\r，\\n这样的特殊字符转义 - 使用Python自己的转义 其它 例子： import ure # As ure doesn't support escapes itself, use of r\"\" strings is not # recommended. regex = ure.compile(\"[\\r\\n]\") regex.split(\"line1\\rline2\\nline3\\r\\n\") # Result: # ['line1', 'line2', 'line3', '', ''] 方法 ure.compile(regex_str[, flags]) 编译正则表达式， 返回regex 对象。 ure.match(regex_str, string) 编译regex_str并匹配字符串。 匹配始终从字符串中的起始位置开始。 ure.search(regex_str, string) 编译regex_str并在字符串中搜索它。 与match不同，这将搜索字符串以匹配正则表达式的第一个位置（如果正则表达式被锚定，它仍然可以是0）。 ure.sub(regex_str, replace, string, count=0, flags=0) 编译regex_str并在字符串中搜索它，用replace替换所有匹配项，并返回新字符串。 replace可以是字符串或函数。 如果它是一个字符串，那么\\和\\g形式的转义序列可用于扩展到相应的组（或不匹配组的空字符串）。 如果replace是一个函数，那么它必须采用一个参数（匹配）并且应该返回一个替换字符串。 如果指定了count并且非零，那么在进行许多替换之后，替换将停止。 flags参数被忽略。 注意：此函数的可用性取决于MicroPython port。 ure.DEBUG 标记值，显示有关已编译表达式的调试信息。 （可用性取决于MicroPython 移植实现。） Regex 对象 编译了的正则表达式。 使用ure.compile()创建此类的实例。 regex.match(string) regex.search(string) regex.sub(replace, string, count=0, flags=0) 类似于模块级函数match（），search（）和sub（）。 如果将相同的正则表达式应用于多个字符串，则使用方法会更高效。 regex.split(string, max_split=-1) 使用正则表达式拆分字符串。 如果给出 max_split，则指定要执行的最大拆分数。 返回字符串列表（如果指定了，则最多可以有 max_split + 1 个元素）。 Match 对象 匹配match（）和search（）方法返回的对象，并传递给sub（）中的替换函数。 match.group(index) 返回匹配（子）字符串。 整个匹配的索引为0，每个捕获组的索引为1和更高。 仅支持数字组。 match.groups() 返回包含匹配组的所有子串的元组。 注意：此方法的可用性取决于MicroPython 移植实现。 match.start([index]) match.end([index]) 返回匹配的子字符串组的开头或结尾的原始字符串中的索引。 index默认为整个组，否则将选择一个组。 注意：这些方法的可用性取决于MicroPython 移植实现。 match.span([index]) 返回2元组（match.start（index），match.end（index））。 注意：此方法的可用性取决于MicroPython 移植 是否实现。 "},"libs/standard/uselect.html":{"url":"libs/standard/uselect.html","title":"uselect","keywords":"","body":""},"libs/standard/usocket.html":{"url":"libs/standard/usocket.html","title":"usocket","keywords":"","body":"usocket – 套接字模块 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档: socket. 该模块提供对BSD套接字接口的访问 与CPython的区别 为了提高效率和一致性，MicroPython中的套接字对象直接实现了stream（类文件）接口。在CPython中，您需要使用makefile（）方法将套接字转换为类文件对象。 MicroPython仍支持此方法（但是无操作），因此在与CPython兼容的情况下，请务必使用它。 套接字地址格式 usocket模块的本机套接字地址格式是getaddrinfo函数返回的不透明数据类型，必须用它来解析文本地址（包括数字地址）： sockaddr = usocket.getaddrinfo('www.micropython.org', 80)[0][-1] # You must use getaddrinfo() even for numeric addresses sockaddr = usocket.getaddrinfo('127.0.0.1', 80)[0][-1] # Now you can use that address sock.connect(addr) 使用getaddrinfo是最有效的（在内存和处理能力方面），而且也是使用地址的可移植方式。 但是，socket模块（注意与此处描述的本机MicroPythonusocket模块的区别）提供了与CPython兼容的方式来使用元组指定地址，如下所述。请注意，取决于MicroPython端口，可以在内置或需要从micropython-lib安装套接字模块（如“MicroPython Unix端口”的情况），并且某些端口仍然只接受元组中的数字地址格式，并要求使用getaddrinfo函数来解析域名。 总的来说： 编写便携式应用程序时始终使用getaddrinfo。 如果您的端口支持快速黑客和交互式使用，则下面描述的元组地址可用作快捷方式。 socket模块的元组地址格式： IPv4：（ipv4_address，port），其中ipv4_address是带有点符号数字IPv4地址的字符串，例如， “8.8.8.8”，端口号和整数端口号在1-65535范围内。请注意，域名不被接受为ipv4_address，应首先使用usocket.getaddrinfo（）解析它们。 IPv6：（ipv6_address，port，flowinfo，scopeid），其中ipv6_address是带冒号数字IPv6地址的字符串，例如： “2001：db8 :: 1”，port是1-65535范围内的整数端口号。 flowinfo必须为0. scopeid是链路本地地址的接口范围标识符。请注意，域名不被接受为ipv6_address，应首先使用usocket.getaddrinfo（）解析它们。 IPv6支持的可用性取决于MicroPython端口。 方法 usocket.socket(af=AF_INET, type=SOCK_STREAM, proto=IPPROTO_TCP) 使用给定的地址系列，套接字类型和协议号创建一个新套接字。请注意，在大多数情况下不需要指定proto（不推荐使用，因为一些MicroPython端口可能会省略IPPROTO_ *常量）。相反，type参数将自动选择所需的协议： # Create STREAM TCP socket socket(AF_INET, SOCK_STREAM) # Create DGRAM UDP socket socket(AF_INET, SOCK_DGRAM) usocket.getaddrinfo(host, port, af=0, type=0, proto=0, flags=0) 将 host / port 参数转换为5元组序列，其中包含用于创建连接到该服务的套接字的所有必要参数。参数af，type和proto（与socket（）函数具有相同的含义）可用于过滤返回哪种地址。如果未指定参数或为零，则可以返回所有地址组合（需要在用户端进行过滤）。 生成的5元组列表具有以下结构： (family, type, proto, canonname, sockaddr) 以下示例显示如何连接到给定的URL： s = usocket.socket() # This assumes that if \"type\" is not specified, an address for # SOCK_STREAM will be returned, which may be not true s.connect(usocket.getaddrinfo('www.micropython.org', 80)[0][-1]) 建议使用过滤参数： s = usocket.socket() # Guaranteed to return an address which can be connect'ed to for # stream operation. s.connect(usocket.getaddrinfo('www.micropython.org', 80, 0, SOCK_STREAM)[0][-1]) 与CPython的区别 如果此函数出错，CPython会引发socket.gaierror异常（OSError子类）。 MicroPython没有socket.gaierror并直接引发OSError。请注意，getaddrinfo（）的错误号形成一个单独的命名空间，可能与uerrno模块中的错误号不匹配。为了区分getaddrinfo（）错误，它们用负数表示，而标准系统错误是正数（错误号可以使用来自异常对象的e.args [0]属性访问）。使用负值是临时细节，可能在将来发生变化。 usocket.inet_ntop(af, bin_addr) 将给定地址族af的二进制网络地址bin_addr转换为文本表示： >>> usocket.inet_ntop(usocket.AF_INET, b\"\\x7f\\0\\0\\1\") '127.0.0.1' usocket.inet_pton(af, txt_addr) 将给定地址族af的文本网络地址txt_addr转换为二进制表示： >>> usocket.inet_pton(usocket.AF_INET, \"1.2.3.4\") b'\\x01\\x02\\x03\\x04' 常量 usocket.AF_INET usocket.AF_INET6 解决家庭类型。可用性取决于特定的MicroPython端口。 usocket.SOCK_STREAM usocket.SOCK_DGRAM 套接字类型。 usocket.IPPROTO_UDP usocket.IPPROTO_TCP IP协议号。可用性取决于特定的MicroPython端口。注意，在调用usocket.socket（）时不需要指定它们，因为SOCK_STREAM套接字类型会自动选择IPPROTO_TCP和SOCK_DGRAM - IPPROTO_UDP。因此，这些常量的唯一实际用途是作为setsockopt（）的参数。 usocket.SOL_* 套接字选项级别（setsockopt（）的参数）。确切的库存取决于MicroPython端口。 usocket.SO_* 套接字选项（setsockopt（）的参数）。确切的库存取决于MicroPython端口。 类 socket 方法 socket.close() 标记套接字已关闭并释放所有资源。一旦发生这种情况，套接字对象上的所有未来操作都将失败。如果协议支持，远程端将接收EOF指示。 套接字在被垃圾收集时会自动关闭，但建议你在完成它们之后立即“关闭”它们。 socket.bind(address) 将套接字绑定到地址。套接字必须尚未绑定。 socket.listen([backlog]) 使服务器接受连接。如果指定了积压，则必须至少为0（如果低，则将其设置为0）;并指定在拒绝新连接之前系统将允许的未接受连接数。如果未指定，则选择默认的合理值。 socket.accept() 接受连接。套接字必须绑定到一个地址并侦听连接。返回值是一对（conn，address），其中conn是可用于在连接上发送和接收数据的新套接字对象，address是绑定到连接另一端的套接字的地址。 socket.connect(address) 连接到地址处的远程套接字。 socket.send(bytes) 将数据发送到套接字。套接字必须连接到远程套接字。返回发送的字节数，可能小于数据长度（“短写”）。 socket.sendall(bytes) 将所有数据发送到套接字。套接字必须连接到远程套接字。与send（）不同，此方法将尝试通过连续发送数据块来发送所有数据。 此方法在非阻塞套接字上的行为未定义。因此，在MicroPython上，建议使用write（）方法，它具有相同的“无短写入”策略来阻塞套接字，并将返回在非阻塞套接字上发送的字节数。 socket.recv(bufsize) 从套接字接收数据。返回值是表示接收数据的字节对象。一次接收的最大数据量由bufsize指定。 socket.sendto(bytes, address) 将数据发送到套接字。套接字不应连接到远程套接字，因为目标套接字由地址指定。 socket.recvfrom(bufsize) 从套接字接收数据。返回值是一对（字节，地址），其中bytes是表示接收数据的字节对象，address是发送数据的套接字的地址。 socket.setsockopt(level, optname, value) 设置给定套接字选项的值。所需的符号常量在套接字模块中定义（SO_ *等）。该值可以是整数或表示缓冲区的类字节对象。 socket.settimeout(value) 注意：并非每个端口都支持此方法，请参阅下文。 阻止套接字操作设置超时。 value参数可以是表示秒的非负浮点数，也可以是None。如果给出非零值，则如果在操作完成之前已经过了超时时间值，则后续的套接字操作将引发“OSError”异常。如果给出零，则套接字处于非阻塞模式。如果给出None，则套接字处于阻塞模式。 并非每个“MicroPython端口”都支持此方法。更便携和通用的解决方案是使用uselect.poll对象。这允许同时等待多个对象（而不仅仅是在套接字上，而是在支持轮询的通用stream对象上）。例： # Instead of: s.settimeout(1.0) # time in seconds s.read(10) # may timeout # Use: poller = uselect.poll() poller.register(s, uselect.POLLIN) res = poller.poll(1000) # time in milliseconds if not res: # s is still not ready for input, i.e. operation timed out 与CPython的区别 CPython在超时的情况下引发socket.timeout异常，这是一个OSError子类。 MicroPython直接引发了一个OSError。如果你使用除了OSError：来捕获异常，你的代码将在MicroPython和CPython中都有效。 socket.setblocking(flag) 设置套接字的阻塞或非阻塞模式：如果flag为false，则套接字设置为非阻塞，否则设置为阻塞模式。 这个方法是某些settimeout（）调用的简写： sock.setblocking(True) 相当于sock.settimeout(None) sock.setblocking(False) i相当于 sock.settimeout(0) socket.makefile(mode='rb', buffering=0) 返回与套接字关联的文件对象。确切的返回类型取决于给makefile（）的参数。支持仅限于二进制模式（'rb'，'wb'和'rwb'）。 CPython的参数：不支持编码，错误和换行符。 与CPython的区别 由于MicroPython不支持缓冲流，因此忽略缓冲参数的值，并将其视为0（无缓冲）。 与CPython的区别 关闭makefile（）返回的文件对象也将关闭原始套接字。 socket.read([size]) 从插槽中读取大小字节。返回一个字节对象。如果没有给出大小，它会读取插座中可用的所有数据，直到EOF;因此，在套接字关闭之前，该方法不会返回。此函数尝试读取所请求的数据（没有“短读取”）。但是，对于非阻塞套接字，这可能是不可能的，然后将返回更少的数据。 socket.readinto(buf[, nbytes]) 将字节读入buf。如果指定了nbytes，则最多读取多个字节。否则，最多读取len（buf）字节。就像read（）一样，此方法遵循“无短读”策略。 返回值：读取并存储到buf中的字节数。 socket.readline() 读一行，以换行符结尾。 返回值：读取的行。 socket.write(buf) 将字节缓冲区写入套接字。此函数将尝试将所有数据写入套接字（无“短写”）。但是，对于非阻塞套接字，这可能是不可能的，并且返回值将小于buf的长度。 返回值：写入的字节数。 exception usocket.error MicroPython没有此异常。 与CPython的区别 CPython曾经有一个socket.error异常现在已被弃用，它是OSError的别名。在MicroPython中，直接使用OSError。 例程 例程 1： 下载图片并显示 注意需要设置 WiFi SSID 和 密码 import socket import network import gc import os import lcd, image fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX) fm.register(board_info.WIFI_TX,fm.fpioa.UART2_RX) uart = machine.UART(machine.UART.UART2,115200,timeout=1000, read_buf_len=4096) nic=network.ESP8285(uart) nic.connect(\"Sipeed_2.4G\",\"------\") sock = socket.socket() addr = socket.getaddrinfo(\"dl.sipeed.com\", 80)[0][-1] sock.connect(addr) sock.send('''GET /MAIX/MaixPy/assets/Alice.bmp HTTP/1.1 Host: dl.sipeed.com cache-control: no-cache ''') img = b\"\" sock.settimeout(5) while True: data = sock.recv(4096) if len(data) == 0: break print(\"rcv:\", len(data)) img = img + data print(len(img)) img = img[img.find(b\"\\r\\n\\r\\n\")+4:] print(len(img)) print(\"save to /sd/Alice.bmp\") f = open(\"/sd/Alice.bmp\",\"wb\") f.write(img) f.close() print(\"save ok\") print(\"display\") img = image.Image(\"/sd/Alice.bmp\") lcd.init() lcd.display(img) 例程 2： 发送图片 import os import socket import network import gc fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX) fm.register(board_info.WIFI_TX,fm.fpioa.UART2_RX) uart = machine.UART(machine.UART.UART2,115200,timeout=1000, read_buf_len=4096) nic=network.ESP8285(uart) nic.connect(\"Sipeed_2.4G\",\"-------\") addr = (\"192.168.0.183\", 3456) sock = socket.socket() sock.connect(addr) sock.settimeout(5) f = open(\"/sd/Alice.bmp\",\"rb\") while True: img = f.read(2048) if not img or (len(img) == 0): break sock.send(img) f.close() sock.close() "},"libs/standard/ustruct.html":{"url":"libs/standard/ustruct.html","title":"ustruct","keywords":"","body":"ustruct – 打包和解包原始数据类型 该模块实现了相应的CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档： struct. 支持的大小/字节顺序前缀: @, , >, !. 支持的格式代码： b, B, h, H, i, I, l, L, q, Q, s, P, f, d （后者2取决于浮点支持）。 函数 calcsize ustruct.calcsize(fmt) 返回存储给定fmt所需的字节数。 pack ustruct.pack(fmt, v1, v2, ...) 根据格式字符串fmt打包值v1，v2，...。返回值是编码值的字节对象。 pack_into ustruct.pack_into(fmt, buffer, offset, v1, v2, ...) 根据格式字符串fmt将值v1，v2，...打包到从offset开始的缓冲区中。从缓冲区的末尾开始计数可能是负数。 unpack ustruct.unpack(fmt, data) 根据格式字符串fmt从data解包。返回值是解压缩值的元组。 unpack_from ustruct.unpack_from(fmt, data, offset=0) 根据格式字符串fmt从 offset 开始从data解包。 offset可能是负数，从缓冲区的末尾开始计数。返回值是解压缩值的元组。 "},"libs/standard/utime.html":{"url":"libs/standard/utime.html","title":"utime","keywords":"","body":"utime – 时间相关的功能 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档： time. utime模块提供获取当前时间和日期，测量时间间隔和延迟的功能。 时间纪元: Unix移植版本使用标准为1970-01-01 00:00:00 UTC的POSIX系统时代。但是，嵌入式移植版本使用的是2000-01-01 00:00:00 UTC的纪元。 维护实际日历日期/时间: 这需要实时时钟（RTC）。在具有底层OS（包括一些RTOS）的系统上，RTC可能是隐含的。设置和维护实际日历时间是OS / RTOS的责任，并且在MicroPython之外完成，它只使用OS API来查询日期/时间。在裸机移植上，系统时间依赖于machine.RTC（）对象。可以使用machine.RTC（）。datetime（tuple）函数设置当前日历时间，并通过以下方式维护： 通过备用电池（可能是特定电路板的附加可选组件）。 使用联网时间协议（需要由移植/用户设置）。 每次上电时由用户手动设置（许多电路板在硬复位时保持RTC时间，但有些可能需要在这种情况下再次设置）。 如果未使用系统/ MicroPython RTC维护实际日历时间，则低于此要求参考当前绝对时间的函数可能与预期不符。 函数 utime.localtime([secs]) 将自纪元（见上文）以秒为单位的时间转换为8元组，其中包含:(年，月，日，小时，分钟，秒，工作日，晚期）如果未提供秒数或无，则为当前时间来自RTC使用。 年份包括世纪（例如2014年）。 月是1-12 mday是1-31 小时是0-23 分钟是0-59 秒是0-59 周一至周日的工作日为0-6 yearday是1-366 utime.mktime() 这是本地时间的反函数。它的参数是一个完整的8元组，表示按当地时间表示的时间。它返回一个整数，它是自2000年1月1日以来的秒数。 utime.sleep(seconds) 睡眠给定的秒数。有些电路板可能会接受秒作为浮点数来休眠几秒钟。请注意，其他板可能不接受浮点参数，因为与它们的兼容性使用 sleep_ms() 和 sleep_us() 函数。 utime.sleep_ms(ms) 给定毫秒数的延迟应为正或0。 utime.sleep_us(us) 给定微秒数的延迟应为正或0。 utime.ticks_ms() 返回一个带有任意参考点的递增毫秒计数器，它在某个值之后回绕。 环绕值未明确公开，但我们将其称为TICKS_MAX以简化讨论。值的周期为TICKS_PERIOD = TICKS_MAX + 1. TICKS_PERIOD保证为2的幂，但在不同硬件的移植之间可能不同。相同的句点值用于所有ticks_ms（），ticks_us（），ticks_cpu（）函数（为简单起见）。因此，这些函数将返回范围[0 .. TICKS_MAX]中的值，包括总TICKS_PERIOD值。请注意，仅使用非负值。在大多数情况下，您应该将这些函数返回的值视为不透明。可用的唯一操作是ticks_diff（）和ticks_add（）函数，如下所述。 注意：直接对这些值执行标准数学运算（+， - ）或关系运算符（，> =）将导致无效结果。执行数学运算然后将其结果作为参数传递给ticks_diff（）或ticks_add（）也将导致后者函数的无效结果。 utime.ticks_us() 就像上面的'ticks_ms（）`一样，但是在几微秒内。 utime.ticks_cpu() 类似于ticks_ms（）和ticks_us（），但系统中的分辨率最高。这通常是CPU时钟，这就是函数以这种方式命名的原因。但它不必是CPU时钟，而是可以使用系统中可用的一些其他定时源（例如，高分辨率定时器）。在'utime`模块级别没有指定此函数的确切时间单位（分辨率），但特定硬件的文档可能提供更具体的信息。此功能用于非常精细的基准测试或非常紧凑的实时循环。避免在便携式代码中使用它。 utime.ticks_add(ticks, delta) 偏移值按给定数字计算，可以是正数也可以是负数。给定一个ticks值，该函数允许在tick值的模块算术定义之后或之后计算ticks值delta ticks（参见上面的ticks_ms（））。 ticks参数必须是调用ticks_ms（），ticks_us（）或ticks_cpu（）函数（或从之前调用ticks_add（））的直接结果。但是，delta可以是任意整数或数字表达式。 ticks_add（）对于计算事件/任务的截止日期非常有用。 （注意：你必须使用ticks_diff（）函数来处理截止日期。） 例子: # Find out what ticks value there was 100ms ago print(ticks_add(time.ticks_ms(), -100)) # Calculate deadline for operation and test for it deadline = ticks_add(time.ticks_ms(), 200) while ticks_diff(deadline, time.ticks_ms()) > 0: do_a_little_of_something() # Find out TICKS_MAX used by this port print(ticks_add(0, -1)) utime.ticks_diff(ticks1, ticks2) 测量从ticks_ms（），ticks_us（）或ticks_cpu（）函数返回的值之间的差异，作为可以回绕的有符号值。 参数顺序与减法运算符相同，ticks_diff（ticks1，ticks2）与ticks1 - ticks2具有相同的含义。但是，ticks_ms（）等函数返回的值可能会回绕，因此直接使用减法会产生不正确的结果。这就是为什么需要ticks_diff（），它实现模块化（或更具体地说，环）算术，即使对于环绕值也能产生正确的结果（只要它们之间不太远，见下文）。该函数返回范围为[-TICKS_PERIOD / 2 .. TICKS_PERIOD / 2-1]的有符号值（这是二进制补码有符号二进制整数的典型范围定义）。如果结果是否定的，则意味着ticks1在时间上早于ticks2。否则，这意味着ticks1发生在ticks2之后。如果ticks1和ticks2彼此分开不超过TICKS_PERIOD / 2-1滴答，则仅保留**。如果不成立，将返回不正确的结果。具体来说，如果两个刻度值相隔TICKS_PERIOD / 2-1刻度，则该值将由该函数返回。但是，如果实时滴答的TICKS_PERIOD / 2已在它们之间传递，则该函数将返回-TICKS_PERIOD / 2，即结果值将回绕到可能值的负范围。 上述限制的非正式理由：假设您被锁在一个房间内，除了标准的12档时钟外无法监控时间的流逝。然后，如果你现在看表盘，不再看13个小时（例如，如果你长时间睡觉），那么一旦你再看一遍，你可能觉得只有1个小时过去了。为了避免这个错误，请定期查看时钟。您的应用程序也应该这样做。 “太长时间睡眠”这个比喻也直接映射到应用程序行为：不要让你的应用程序运行任何单个任务太长时间。分步运行任务，并在两者之间进行计时。 ticks_diff() 旨在适应各种使用模式，其中包括： 超时轮询。在这种情况下，事件的顺序是已知的，你只会处理ticks_diff（）的正面结果： # Wait for GPIO pin to be asserted, but at most 500us start = time.ticks_us() while pin.value() == 0: if time.ticks_diff(time.ticks_us(), start) > 500: raise TimeoutError 调度事件。 在这种情况下，如果事件过期，则ticks_diff（）结果可能为负： # This code snippet is not optimized now = time.ticks_ms() scheduled_time = task.scheduled_time() if ticks_diff(scheduled_time, now) > 0: print(\"Too early, let's nap\") sleep_ms(ticks_diff(scheduled_time, now)) task.run() elif ticks_diff(scheduled_time, now) == 0: print(\"Right at time!\") task.run() elif ticks_diff(scheduled_time, now) 注意：不要将time（）值传递给ticks_diff（），你应该对它们使用常规的数学运算。但请注意，time（）可能（也会）溢出。这被称为https://en.wikipedia.org/wiki/Year_2038_problem . utime.time() 返回自纪元以来的整数秒数，假设如上所述设置和维护基础RTC。如果未设置 RTC，则此函数返回自特定硬件移植参考时间点以来的秒数（对于没有电池供电的 RTC 的嵌入式电路板，通常自上电或复位后）。如果要开发便携式 MicroPython 应用程序，则不应依赖此函数来提供高于第二的精度。如果你需要更高的精度，使用ticks_ms（）和ticks_us（）函数，如果你需要日历时间，localtime（）没有参数是一个更好的选择。 与CPython的区别 在 CPython 中，此函数返回自 Unix 纪元（1970-01-01 00:00 UTC）以来的秒数，作为浮点数，通常具有微秒精度。 使用 MicroPython，只有 Unix 移植版本使用相同的纪元，如果浮点精度允许，则返回亚秒精度。 嵌入式硬件通常没有浮点精度来表示长时间范围和亚秒精度，因此它们使用具有第二精度的整数值。 某些嵌入式硬件也缺少电池供电的 RTC，因此返回自上次上电或其他相对硬件特定点（例如复位）以来的秒数。 time.ticks() 等同于 time.ticks_ms time.clock() 获取 clock 对象 返回值 clock 对象 clock 对象 由 time.clock() 返回 clock.tick() 记录开始时间（ms）， 与clock.fps()搭配使用可以计算fps 返回值 None clock.fps() 根据上一个调用clock.tick()到现在的时间计算出帧率（fps） 比如： import sensor import time clock = time.clock() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) while True: clock.tick() sensor.snapshot() print(\"fps = \",clock.fps()) clock.reset() 重置所有标记 clock.avg() 根据上一个调用clock.tick()到现在的时间计算出每帧消耗的时间 "},"libs/standard/uzlib.html":{"url":"libs/standard/uzlib.html","title":"uzlib","keywords":"","body":"uzlib — zlib 解压缩 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档：zlib。 该模块允许解压使用 DEFLATE 算法压缩的二进制数据（通常用于zlib库和gzip存档器）。 压缩尚未实现。 函数 decompress 解压 uzlib.decompress(data, wbits=0, bufsize=0) 参数 wbits： 压缩期间使用的 DEFLATE 字典窗口大小（8-15，字典大小是该值的2的幂）。 另外，如果值为正，则假定数据为 zlib 流（使用 zlib 头）。 否则，如果它是负数，则假定它是原始 DEFLATE 流。 bufsize： 参数用于与CPython兼容， 可忽略。 返回值 将解压缩的数据作为bytes类型返回。 DecompIO 创建一个流包装器，允许对另一个流中的压缩数据进行透明解压缩。 这允许处理具有大于可用堆大小的数据的压缩流。 除了decompress（）中描述的值之外，wbits可以取值 24..31（16+8..15），这意味着输入流具有gzip头。 class uzlib.DecompIO(stream, wbits=0) 与 CPython 的不同 这个类是MicroPython扩展。它包含在临时基础上，可能会在以后的版本中进行大量更改或删除。 "},"libs/machine/":{"url":"libs/machine/","title":"machine","keywords":"","body":"machine machine 库主要包含了与硬件相关的各种接口，如下： I2C SPI Timer PWM UART "},"libs/machine/i2c.html":{"url":"libs/machine/i2c.html","title":"I2C","keywords":"","body":"machine.I2C I2C 总线协议，简单地使用两条线（SCL，SDA）可以控制多个从机（主机模式）。 支持主机模式和从机模式 7 位/10 位寻址模式 标准模式 快速模式 超快速模式 高速模式 3.4Mb/s 构造函数 class machine.I2C(id, mode=I2C.MODE_MASTER, scl=None, sda=None, freq=400000, timeout=1000, addr=0, addr_size=7, on_recieve=None, on_transmit=None, on_event=None) 通过指定的参数新建一个 I2C 对象 参数 id： I2C ID, [0~2] (I2C.I2C0~I2C.I2C2) mode： 模式， 主机(I2C.MODE_MASTER)和从机（I2C.MODE_SLAVE)模式 scl： SCL 引脚，直接传引脚编号即可，取值范围： [0,47]。 可以不设置，而是使用 fm 统一管理引脚映射。 sda： SDA 引脚，直接传引脚编号即可，取值范围： [0,47]。 可以不设置，而是使用 fm 统一管理引脚映射。 freq： I2C通信频率， 支持标准100Kb/s, 快速400Kb/s， 以及更高速率（硬件支持超快速模式1000Kb/s，以及高速模式3.4Mb/s） timeout： 超时时间，目前这个参数保留，设置无效 addr： 从机地址，如果是主机模式不用设置， 从机模式则代表从机（本机）地址 addr_size： 地址长度， 支持 7 位寻址和 10 位寻址， 取值7或者10 on_recieve： 从机模式的接收回调函数 on_transmit： 从机模式的发送回调函数 on_event： 从机模式的事件函数（开始事件和结束事件） 方法 init 类似构造函数 I2C.init(id, mode=Timer.MODE_MASTER, scl, sda, freq=400000, timeout=1000, addr=0, addr_size=7, on_recieve=None, on_transmit=None, on_event=None) 参数 与构造函数相同 返回值 无 scan 扫描I2C总线上的从机 I2C.scan() 参数 无 返回值 list 对象， 包含了所有扫描到的从机地址 readfrom 从总线读取数据 I2C.readfrom(addr, len, stop=True) 参数 addr: 从机地址 len： 数据长度 stop： 是否产生停止信号，保留，目前只能使用默认值Ture 返回值 读取到的数据，bytes 类型 readfrom_into 读取数据并放到制定变量中 I2C.readfrom_into(addr, buf, stop=True) 参数 addr: 从机地址 buf： bytearray类型， 定义了长度，读取到的数据存放在此 stop： 是否产生停止信号，保留，目前只能使用默认值Ture 返回值 无 writeto 发送数据到从机 I2C.writeto(addr, buf, stop=True) 参数 addr: 从机地址 buf： 需要发送的数据 stop： 是否产生停止信号，保留，目前只能使用默认值Ture 返回值 成功发送的字节数 readfrom_mem 读取从机寄存器 I2C.readfrom_mem(addr, memaddr, nbytes, mem_size=8) 参数 addr: 从机地址 memaddr： 从机寄存器地址 nbytes： 需要读取的长度 mem_size： 寄存器宽度， 默认为8位 返回值 返回bytes类型的读取到的数据 readfrom_mem_into 读取从机寄存器值到指定变量中 I2C.readfrom_mem_into(addr, memaddr, buf, mem_size=8) 参数 addr: 从机地址 memaddr： 从机寄存器地址 buf： bytearray类型， 定义了长度，读取到的数据存放在此 mem_size： 寄存器宽度， 默认为8位 返回值 无 writeto_mem 写数据到从机寄存器 I2C.writeto_mem(addr, memaddr, buf, mem_size=8) 参数 addr: 从机地址 memaddr： 从机寄存器地址 buf： 需要写的数据 mem_size： 寄存器宽度， 默认为8位 返回值 无 deinit/_del_ 注销I2C硬件，释放占用的资源，关闭I2C时钟 I2C.deinit() 参数 无 返回值 无 例子 i2c.deinit() 或者 del i2c 常量 I2C0: I2C 0 I2C1: I2C 1 I2C2: I2C 2 MODE_MASTER: 作为主机模式 MODE_SLAVE: 作为从机模式 I2C_EV_START: 事件类型，开始信号 I2C_EV_RESTART: 事件类型，重新开始信号 I2C_EV_STOP: 事件类型，结束信号 例程 例程 1： 扫描从机设备 from machine import I2C i2c = I2C(I2C.I2C0, freq=100000, scl=28, sda=29) devices = i2c.scan() print(devices) 例程 2： 读写 import time from machine import I2C i2c = I2C(I2C.I2C0, freq=100000, scl=28, sda=29) i2c.writeto(0x24,b'123') i2c.readfrom(0x24,5) 例程 3： 从机模式 from machine import I2C count = 0 def on_receive(data): print(\"on_receive:\",data) def on_transmit(): count = count+1 print(\"on_transmit, send:\",count) return count def on_event(event): print(\"on_event:\",event) i2c = I2C(I2C.I2C0, mode=I2C.MODE_SLAVE, scl=28, sda=29, addr=0x24, addr_size=7, on_receive=on_receive, on_transmit=on_transmit, on_event=on_event) 例程 4： OLED(ssd1306 128x64) import time from machine import I2C SSD1306_CMD = 0 SSD1306_DATA = 1 SSD1306_ADDR = 0x3c def oled_init(i2c): i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xAE, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x20, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x10, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xb0, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xc8, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x00, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x10, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x40, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x81, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xff, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xa1, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xa6, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xa8, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x3F, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xa4, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xd3, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x00, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xd5, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xf0, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xd9, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x22, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xda, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x12, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xdb, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x20, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x8d, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x14, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xaf, mem_size=8) def oled_on(i2c): i2c.writeto_mem(SSD1306_ADDR, 0x00, 0X8D, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0X14, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0XAF, mem_size=8) def oled_off(i2c): i2c.writeto_mem(SSD1306_ADDR, 0x00, 0X8D, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0X10, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0XAE, mem_size=8) def oled_fill(i2c, data): for i in range(0,8): i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xb0+i, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x10, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x01, mem_size=8) for j in range(0,128): i2c.writeto_mem(SSD1306_ADDR, 0x40, data, mem_size=8) i2c = I2C(I2C.I2C0, mode=I2C.MODE_MASTER, freq=400000, scl=28, sda=29, addr_size=7) time.sleep(1) oled_init(i2c) oled_fill(i2c, 0xff) "},"libs/machine/pwm.html":{"url":"libs/machine/pwm.html","title":"PWM","keywords":"","body":"machine.PWM PWM： 脉宽调制模块， 硬件支持的PWM， 可以指定任意引脚（0到47引脚） 每个 PWM 依赖于一个定时器， 即当定时器与 PWM 功能绑定后， 不能作为普通定时器使用了。 因为有 3 个定时器， 每个定时器有 4 个通道， 即最大可以同时产生 12 路 PWM 波形 构造函数 class machine.PWM(tim, freq, duty, pin, enable=True) 通过指定的参数新建一个 PWM 对象 参数 tim: 每个PWM依赖一个定时器来产生波形， 所以这里需要传一个定时器对象，这个定时器对象必须初始化时必须指定定时器 ID 和通道号 freq： PWM 波形频率 duty： PWM 占空比， 指高电平占整个周期的百分比，取值：[0,100] [pin]： PWM 输出引脚。 可以不设置，而是使用 fm 统一管理引脚映射。 enable： 是否立即开始产生波形，默认位True，及对象生成后立即开始在指定的引脚上产生 PWM 波形 方法 init 类似构造函数 PWM.init(tim, freq, duty, pin, enable=True) 参数 与构造函数相同 返回值 无 freq 获取或者设置 PWM 频率 PWM.freq(freq) 参数 freq： PWM 频率， 可选参数， 如果不传参数则步设置只返回当前频率值 返回值 当前设置的实际的 PWM 频率 duty 获取或者设置 PWM 占空比 PWM.duty(duty) 参数 duty： PWM 占空比 可选， 如果不传参数则步设置只返回当前占空比值 返回值 当前设置的 PWM 占空比值 enable 使能 PWM 输出， 使指定的引脚上立即产生波形 PWM.enable() 参数 无 返回值 无 disable 失能 PWM 输出， 指定的引脚不再产生波形 PWM.disable() 参数 无 返回值 无 deinit/_del_ 注销 PWM 硬件，释放占用的资源，关闭 PWM 时钟 PWM.deinit() 参数 无 返回值 无 例子 pwm.deinit() 或者 del pwm 常量 无 例程 例程 1 （呼吸灯） from machine import Timer,PWM import time tim = Timer(Timer.TIMER0, Timer.CHANNEL0, mode=Timer.MODE_PWM) ch = PWM(tim, freq=500000, duty=50, pin=board_info.LED_G) duty=0 dir = True while True: if dir: duty += 10 else: duty -= 10 if duty>100: duty = 100 dir = False elif duty 例程 2 import time import machine tim = machine.Timer(machine.Timer.TIMER0, machine.Timer.CHANNEL0, mode=machine.Timer.MODE_PWM) ch0 = machine.PWM(tim, freq=3000000, duty=20, pin=board_info.LED_G, enable=False) ch0.enable() time.sleep(3) ch0.freq(2000000) print(\"freq:\",ch0.freq()) ch0.duty(60) time.sleep(3) ch0.disable() "},"libs/machine/spi.html":{"url":"libs/machine/spi.html","title":"SPI","keywords":"","body":"machine.SPI SPI（Serial Peripheral Interface） 是一个同步串行协议，由主机和从机组成。 标准4线模式由 SCK（SCLK）， CS（片选）， MOSI， MISO 4条线连接主从机 在 K210 上， SPI 有一下特征： 共有 4 个 SPI 设备， 其中 SPI0 、SPI1、 SPI3 只能工作在主机模式下， SPI2 只能工作在从机模式时下， 在 MaixPy 上， SPI3已经用来连接了 SPI Flash， 暂时保留， 以后如果有必要再考虑开放接口与 SPI Flash 分时复用 支持 1/2/4/8 线全双工模式， 在 MaixPy 中， 目前只支持标准（摩托罗拉）4线全双工模式（即 SCK， MOSI， MISO， CS 四个引脚） 最高传输速率45M 支持DMA 4个可配置任意引脚的硬件片选 构造函数 class machine.SPI(id, mode=SPI.MODE_MASTER, baudrate=500000, polarity=0, phase=0, bits=8, firstbit=SPI.MSB, sck, mosi, miso, cs0, cs1, cs2, cs3) 通过指定的参数新建一个 SPI 对象 参数 id： SPI ID， 取值范围[0,3]， 目前只支持 0 和 1， 并且只能是主机模式， 2 只能作为从机，目前未实现， 3 保留 mode： SPI 模式， MODE_MASTER 或者MODE_MASTER_2或者MODE_MASTER_4或者MODE_MASTER_8或者MODE_SLAVE， 目前只支持MODE_MASTER baudrate： SPI 波特率（频率） polarity： 极性， 取值为 0 或 1， 表示 SPI 在空闲时的极性， 0 代表低电平， 1 代表高电平 phase： 相， 取值位 0 或 1， 表示在时钟的第一个还是第二个跳变沿采集数据， 0 表示第一个， 1 表示第二个 bits： 数据宽度， 默认值为8， 取值范围[4,32] firstbit： 指定传输采用 MSB 还是 LSB 顺序传输， 默认 SPI.MSB sck: SCK（时钟）引脚， 可直接传引脚数值，取值范围：[0,47]。 可以不设置，而是使用 fm 统一管理引脚映射。 mosi: MOSI（主机输出） 引脚， 可直接传引脚数值，取值范围：[0,47]。 可以不设置，而是使用 fm 统一管理引脚映射。 miso: MISO（主机输入） 引脚， 可直接传引脚数值，取值范围：[0,47]。 可以不设置，而是使用 fm 统一管理引脚映射。 cs0: CS0（片选） 引脚， 可直接传引脚数值，取值范围：[0,47]。 可以不设置，而是使用 fm 统一管理引脚映射。 cs1: CS1（片选） 引脚， 可直接传引脚数值，取值范围：[0,47]。 可以不设置，而是使用 fm 统一管理引脚映射。 cs2: CS2（片选） 引脚， 可直接传引脚数值，取值范围：[0,47]。 可以不设置，而是使用 fm 统一管理引脚映射。 cs3: CS3（片选） 引脚， 可直接传引脚数值，取值范围：[0,47]。 可以不设置，而是使用 fm 统一管理引脚映射。 d0~d7： 数据引脚， 在非标准4线模式中使用，目前保留。 可以不设置，而是使用 fm 统一管理引脚映射。 方法 init 类似构造函数 SPI.init(id, mode=SPI.MODE_MASTER, baudrate=500000, polarity=0, phase=0, bits=8, firstbit=SPI.MSB, sck, mosi, miso, cs0) 参数 与构造函数相同 返回值 无 read 读取数据 SPI.read(nbytes, write=0x00, cs=SPI.CS0) 参数 nbytes： 需要读取的长度 cs： 选择片选引脚， 在初始化时已经为cs0~cs3设置了引脚，这里只需要选择SPI.CS0~SPI.CS3即可，默认为SPI.CS0 write： 因为是全双工，设置在读取时MOSI引脚的值，默认为0x00，即始终为低电平 返回值 bytes类型的数据 readinto 读取数据，并放到指定变量中 SPI.readinto(buf, write=0x00, cs=SPI.CS0) 参数 buf： bytearray 类型， 定义了长度，读取完成后数据保存在此 cs： 选择片选引脚， 在初始化时已经为cs0~cs3设置了引脚，这里只需要选择SPI.CS0~SPI.CS3即可，默认为SPI.CS0 write： 因为是全双工，设置在读取时MOSI引脚的值，默认为0x00，即始终为低电平 返回值 无 write 发送数据 SPI.write(buf, cs=SPI.CS0) 参数 buf： bytearray 类型， 定义了数据及长度 cs： 选择片选引脚， 在初始化时已经为cs0~cs3设置了引脚，这里只需要选择SPI.CS0~SPI.CS3即可，默认为SPI.CS0 返回值 无 write_readinto 发送数据，同时读取数据到变量，即全双工 SPI.write(write_buf, read_buf, cs=SPI.CS0) 参数 write_buf： bytearray 类型， 定义了需要发送的数据及长度 read_buf： bytearray 类型， 定义了接收数据存放的位置 cs： 选择片选引脚， 在初始化时已经为cs0~cs3设置了引脚，这里只需要选择SPI.CS0~SPI.CS3即可，默认为SPI.CS0 返回值 无 deinit/_del_ 注销 SPI，释放硬件，关闭 SPI 时钟 SPI.deinit() 参数 无 返回值 无 例子 spi.deinit() 或者 del spi 常量 SPI0: SPI 0 SPI1: SPI 1 SPI2: SPI 2 MODE_MASTER: 作为主机模式 MODE_MASTER_2: 作为主机模式 MODE_MASTER_4: 作为主机模式 MODE_MASTER_8: 作为主机模式 MODE_SLAVE: 作为从机模式 MSB： MSB， 即先发送高位或高字节 LSB： LSB， 即先发送低位或者低字节 CS0： 片选0 CS1： 片选1 CS2： 片选2 CS3： 片选3 例程 例程 1： 基本读写 from machine import SPI spi1 = SPI(SPI.SPI1, mode=SPI.MODE_MASTER, baudrate=10000000, polarity=0, phase=0, bits=8, firstbit=SPI.MSB, sck=28, mosi=29, miso=30, cs0=27) w = b'1234' r = bytearray(4) spi1.write(w) spi1.write(w, cs=SPI.CS0) spi1.write_readinto(w, r) spi1.read(5, write=0x00) spi1.readinto(r, write=0x00) "},"libs/machine/timer.html":{"url":"libs/machine/timer.html","title":"Timer","keywords":"","body":"machine.Timer 硬件定时器，可以用来定时触发任务或者处理任务，设定时间到了后可以触发中断（调用回调函数），精度比软件定时器高。 需要注意的是，定时器在不同的硬件中可能会有不同的表现。MicroPython 的 Timer 类定义了在给定时间段内（或在一段延迟后执行一次回调）执行回调的基本操作，并允许特定的硬件上定义更多的非标准行为（因此不能移植到其他板）。 共有 3 个定时器， 每个定时器有 4 个通道可以使用 构造函数 class machine.Timer(id, channel, mode=Timer.MODE_ONE_SHOT, period=1000, unit=Timer.UNIT_MS, callback=None, arg=None, start=True, priority=1, div=0) 通过指定的参数新建一个 Timer 对象 参数 id: Timer ID, [0~2] (Timer.TIMER0~TIMER2) channel: Timer 通道, [Timer.CHANNEL0~Timer.CHANNEL3] mode: Timer 模式, MODE_ONE_SHOT 或者 MODE_PERIODIC 或者 MODE_PWM period: Timer 周期, 在启动定时器后 period 时间， 回调函数将会被调用，(0,~) unit: 设置周期的单位，默认位毫秒（ms），Timer.UNIT_S 或者 Timer.UNIT_MS 或者 Timer.UNIT_US 或者Timer.UNIT_NS callback: 定时器回调函数， 定义了两个参数， 一个是定时器对象Timer， 第二个是在定义对象是希望传的参数arg，更多请看arg参数解释 注意：回调函数是在中断中调用的，所以在回调函数中请不要占用太长时间以及做动态分配开关中断等动作 arg: 希望传给回调函数的参数，作为回调函数的第二个参数 start: 是否在对象构建成功后立即开始定时器， True：立即开始， False:不立即开启，需要调用start()函数来启动定时器 priority: 硬件定时器中断优先级， 与特定的CPU相关， 在K210中，取值范围是[1,7]， 值越小优先级越高 div: 硬件定时器分频器，取值范围[0,255]， 默认为0， clk_timer（定时器时钟频率） = clk_pll0（锁相环0频率）/2^(div+1) clk_timer*period(unit:s) 应该 =1 方法 init 类似构造函数 Timer.init(id, channel, mode=Timer.MODE_ONE_SHOT, period=1000, unit=Timer.UNIT_MS, callback=None, arg=None, start=True, priority=1, div=0) 参数 类似构造函数 返回值 无 callback_arg 获取设置的传给回调函数的参数，只能是 Timer 对象调用， 类 Timer 不能调用 callback 获取或者设置回调函数 Timer.callback(callback) 参数 callback： 设置的回调函数，可选参数， 如果不传参数，则只返回先有的回调函数 返回值 当前的回调函数 例子 def on_timer(timer): print(\"time up:\",timer) print(\"param:\",timer.callback_arg()) tim.callback(on_timer) print(on_timer, tim.callback()) period 获取或者设置定时周期 Timer.period(period) 参数 period： 可选参数，配置周期， 如果不传参数， 则只返回当前周期值 返回值 当前周期值 例子 tim.period(2000) print( tim.period() ) start 启动定时器 Timer.start() 参数 无 返回值 无 例子 tim.start() stop 停止定时器 Timer.stop() 参数 无 返回值 无 restart 重新开启定时器 Timer.restart() 参数 无 返回值 无 deinit/_del_ 注销定时器，并且注销硬件的占用，关闭硬件的时钟 Timer.deinit() 参数 无 返回值 无 例子 tim.deinit() 或者 del tim 常量 TIMER0: Timer0 id TIMER1: Timer1 id TIMER2: Timer2 id CHANNEL0: Timer 通道 0 CHANNEL1: Timer 通道 1 CHANNEL2: Timer 通道 2 CHANNEL3: Timer 通道 3 MODE_ONE_SHOT: Timer 只运行一次（回调一次） MODE_PERIODIC: Timer 始终运行（连续回调） MODE_PWM: 定时器不用来回调函数，用以产生PWM UNIT_S: 单位秒 (s) UNIT_MS: 单位毫秒 (ms) UNIT_US: 单位微秒 (us) UNIT_NS: 单位纳秒 (ns) 例程 例程 1 定时3秒后打印信息 from machine import Timer def on_timer(timer): print(\"time up:\",timer) print(\"param:\",timer.callback_arg()) tim = Timer(Timer.TIMER0, Timer.CHANNEL0, mode=Timer.MODE_ONE_SHOT, period=3000, callback=on_timer, arg=on_timer) print(\"period:\",tim.period()) 例程 2 每隔 1 秒打印消息， 停止 5 秒后再重启， 5 秒后关闭并注销定时器 import time from machine import Timer def on_timer(timer): print(\"time up:\",timer) print(\"param:\",timer.callback_arg()) tim = Timer(Timer.TIMER0, Timer.CHANNEL0, mode=Timer.MODE_PERIODIC, period=1, unit=Timer.UNIT_S, callback=on_timer, arg=on_timer, start=False, priority=1, div=0) print(\"period:\",tim.period()) tim.start() time.sleep(5) tim.stop() time.sleep(5) tim.restart() time.sleep(5) tim.stop() del tim "},"libs/machine/uart.html":{"url":"libs/machine/uart.html","title":"UART","keywords":"","body":"machine.UART uart模块主要用于驱动开发板上的异步串口，可以自由对uart进行配置。k210一共有3个uart，每个uart可以进行自由的引脚映射。 构造 引脚映射 在使用uart前，我们需要使用fm来对芯片引脚进行映射和管理。如下所示，将PIN10设置为uart2的发送引脚，PIN11设置为uart2的接收引脚 fm.register(board_info.PIN10,fm.fpioa.UART2_TX) fm.register(board_info.PIN11,fm.fpioa.UART2_RX) 构造函数 uart = machine.UART(uart,baudrate,bits,parity,stop,timeout, read_buf_len) 通过指定的参数新建一个 UART 对象 参数 uart UART号，使用指定的UART，可以通过 machine.UART. 按tab键来补全 baudrate: UART 波特率 bits: UART 数据宽度，支持 5/6/7/8 (默认的 REPL 使用的串口（UARTHS）只支持 8 位模式)， 默认 8 parity: 奇偶校验位，支持 None, machine.UART.PARITY_ODD, machine.UART.PARITY_EVEN （默认的 REPL 使用的串口（UARTHS）只支持 None）， 默认 None stop: 停止位， 支持 1， 1.5, 2， 默认 1 timeout: 串口接收超时时间 read_buf_len： 串口接收缓冲，串口通过中断来接收数据，如果缓冲满了，将自动停止数据接收 返回值 UART对象 方法 init 用于初始化uart，一般在构造对象时已经初始化，这里用在重新初始化uart uart.init(baudrate,bits,parity,stop,timeout, read_buf_len) 参数 同构造函数，但不需要第一个UART号 返回值 无 read 用于读取串口缓冲中的数据 uart.read(num) 参数 num: 读取字节的数量，一般填入缓冲大小，如果缓冲中数据的数量没有 num 大，那么将只返回缓冲中剩余的数据 返回值 bytes类型的数据 readline 用于读取串口缓冲数据的一航 uart.readline(num) num: 读取行的数量 返回值 *bytes类型的数据 write 用于使用串口发送数据 uart.write(buf) 参数 buf: 需要发送到数据 返回值 写入的数据量 deinit 注销 UART 硬件，释放占用的资源 UART.deinit() 参数 无 返回值 无 repl_uart() 获取用于 REPL 的串口对象 返回值 用于 REPL 的串口对象， 默认初始化位 115200 8 N 1 例程 例程 1 在运行里程之前，请确认 PIN15 已经连接到 PIN10， PIN17 已经连接到 PIN9 运行程序后，可以在终端看到 baudrate:115200 bits:8 parity:0 stop:0 ---check Successfully 的打印信息 from fpioa_manager import fm from machine import UART fm.register(board_info.PIN15,fm.fpioa.UART1_TX) fm.register(board_info.PIN17,fm.fpioa.UART1_RX) fm.register(board_info.PIN9,fm.fpioa.UART2_TX) fm.register(board_info.PIN10,fm.fpioa.UART2_RX) uart_A = UART(UART.UART1, 115200, 8, None, 1, timeout=1000, read_buf_len=4096) uart_B = UART(UART.UART2, 115200, 8, None, 1, timeout=1000, read_buf_len=4096) write_str = 'hello world' for i in range(20): uart_A.write(write_str) read_data = uart_B.read() read_str = read_data.decode('utf-8') print(\"string = \",read_str) if read_str == write_str: print(\"baudrate:115200 bits:8 parity:None stop:1 ---check Successfully\") uart_A.deinit() uart_B.deinit() del uart_A del uart_B 例程 2 AT模块串口 fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX) fm.register(board_info.WIFI_TX,fm.fpioa.UART2_RX) uart = machine.UART(machine.UART.UART2,115200,timeout=1000, read_buf_len=4096) 例程 3 修改 REPL 串口波特率 from machine import UART repl = UART.repl_uart() repl.init(1500000, 8, None, 1, read_buf_len=2048) 例程 3 修改 REPL 串口 from machine import UART fm.register(board_info.PIN15,fm.fpioa.UART1_TX) fm.register(board_info.PIN17,fm.fpioa.UART1_RX) uart = machine.UART(UART.UART1, 115200) UART.set_repl_uart(uart) "},"libs/Maix/":{"url":"libs/Maix/","title":"Maix","keywords":"","body":"Maix库 FPIOA GPIO KPU FFT I2S audio "},"libs/Maix/fpioa.html":{"url":"libs/Maix/fpioa.html","title":"FPIOA","keywords":"","body":"FPIOA (现场可编程 IO 阵列， Field Programmable Input and Output Array) K210 支持每个外设随意映射到任意引脚， 使用 FPIOA 功能来实现。 注意: 一下 GPIOHS 默认已经被使用， 程序中如非必要尽量不要使用： GPIOHS 功能 GPIOHS31 LCD_DC GPIOHS30 LCD_RST GPIOHS29 SD_CS GPIOHS28 MIC_LED_CLK GPIOHS27 MIC_LED_DATA 类 FPIOA 方法 help(func) 显示外设及其简要描述 参数 func： 外设名（功能/编号），可以不传参， 则以表格的形式显示所有外设名即简要描述，这个表格也可以在本页的末尾找到（附录：外设表）； 如果传参，则传一个整型值， 找到该编号对应的外设后会打印外设名和描述， 比如 FPIOA.JTAG_TCLK 或者 fm.fpioa.JTAG_TCLK（fm在本页后面介绍） 或者 0 比如： from Maix import FPIOA fpioa = FPIOA() fpioa.help() fpioa.help(0) fpioa.help(fpioa.JTAG_TCLK) fm.fpioa.help() fm.fpioa.help(fm.fpioa.JTAG_TCLK) 返回 外设名及其简要描述 set_function(pin, func) 设置引脚对应的外设功能， 即引脚映射 参数 pin： 引脚编号，取值 [0, 47]， 具体的引脚连接请看电路图， 也可以使用 board_info. 然后按 TAB 按键补全来获得板子的常用引脚，比如 board_info.LED_G func： 外设功能，传一个整型值，可以通过 fm.fpioa.help()或者查本页末尾的 附录： 外设表 表得到 比如 需要将连接 绿色 LED 的引脚映射到 高速 GPIO0 上： fpioa = FPIOA() fpioa.set_function(board_info.LED_G, fm.fpioa.GPIOHS0) get_Pin_num(func) 获取外设映射到哪个引脚上了 参数 func： 外设功能，传一个整型值，可以通过 fm.fpioa.help()或者查本页末尾的 附录： 外设表 表得到 比如： fpioa = FPIOA() fpioa.set_function(board_info.LED_G, fm.fpioa.GPIOHS0) pin = fpioa.get_Pin_num(fm.fpioa.GPIOHS0) if pin == board_info.LED_G: print(\"set function ok\") 附录： 外设表 外设功能（func） 简要描述 JTAG_TCLK JTAG Test Clock JTAG_TDI JTAG Test Data In JTAG_TMS JTAG Test Mode Select JTAG_TDO JTAG Test Data Out SPI0_D0 SPI0 Data 0 SPI0_D1 SPI0 Data 1 SPI0_D2 SPI0 Data 2 SPI0_D3 SPI0 Data 3 SPI0_D4 SPI0 Data 4 SPI0_D5 SPI0 Data 5 SPI0_D6 SPI0 Data 6 SPI0_D7 SPI0 Data 7 SPI0_SS0 SPI0 Chip Select 0 SPI0_SS1 SPI0 Chip Select 1 SPI0_SS2 SPI0 Chip Select 2 SPI0_SS3 SPI0 Chip Select 3 SPI0_ARB SPI0 Arbitration SPI0_SCLK SPI0 Serial Clock UARTHS_RX UART High speed Receiver UARTHS_TX UART High speed Transmitter RESV6 Reserved function RESV7 Reserved function CLK_SPI1 Clock SPI1 CLK_I2C1 Clock I2C1 GPIOHS0 GPIO High speed 0 GPIOHS1 GPIO High speed 1 GPIOHS2 GPIO High speed 2 GPIOHS3 GPIO High speed 3 GPIOHS4 GPIO High speed 4 GPIOHS5 GPIO High speed 5 GPIOHS6 GPIO High speed 6 GPIOHS7 GPIO High speed 7 GPIOHS8 GPIO High speed 8 GPIOHS9 GPIO High speed 9 GPIOHS10 GPIO High speed 10 GPIOHS11 GPIO High speed 11 GPIOHS12 GPIO High speed 12 GPIOHS13 GPIO High speed 13 GPIOHS14 GPIO High speed 14 GPIOHS15 GPIO High speed 15 GPIOHS16 GPIO High speed 16 GPIOHS17 GPIO High speed 17 GPIOHS18 GPIO High speed 18 GPIOHS19 GPIO High speed 19 GPIOHS20 GPIO High speed 20 GPIOHS21 GPIO High speed 21 GPIOHS22 GPIO High speed 22 GPIOHS23 GPIO High speed 23 GPIOHS24 GPIO High speed 24 GPIOHS25 GPIO High speed 25 GPIOHS26 GPIO High speed 26 GPIOHS27 GPIO High speed 27 GPIOHS28 GPIO High speed 28 GPIOHS29 GPIO High speed 29 GPIOHS30 GPIO High speed 30 GPIOHS31 GPIO High speed 31 GPIO0 GPIO pin 0 GPIO1 GPIO pin 1 GPIO2 GPIO pin 2 GPIO3 GPIO pin 3 GPIO4 GPIO pin 4 GPIO5 GPIO pin 5 GPIO6 GPIO pin 6 GPIO7 GPIO pin 7 UART1_RX UART1 Receiver UART1_TX UART1 Transmitter UART2_RX UART2 Receiver UART2_TX UART2 Transmitter UART3_RX UART3 Receiver UART3_TX UART3 Transmitter SPI1_D0 SPI1 Data 0 SPI1_D1 SPI1 Data 1 SPI1_D2 SPI1 Data 2 SPI1_D3 SPI1 Data 3 SPI1_D4 SPI1 Data 4 SPI1_D5 SPI1 Data 5 SPI1_D6 SPI1 Data 6 SPI1_D7 SPI1 Data 7 SPI1_SS0 SPI1 Chip Select 0 SPI1_SS1 SPI1 Chip Select 1 SPI1_SS2 SPI1 Chip Select 2 SPI1_SS3 SPI1 Chip Select 3 SPI1_ARB SPI1 Arbitration SPI1_SCLK SPI1 Serial Clock SPI_SLAVE_D0 SPI Slave Data 0 SPI_SLAVE_SS SPI Slave Select SPI_SLAVE_SCLK SPI Slave Serial Clock I2S0_MCLK I2S0 Master Clock I2S0_SCLK I2S0 Serial Clock(BCLK) I2S0_WS I2S0 Word Select(LRCLK) I2S0_IN_D0 I2S0 Serial Data Input 0 I2S0_IN_D1 I2S0 Serial Data Input 1 I2S0_IN_D2 I2S0 Serial Data Input 2 I2S0_IN_D3 I2S0 Serial Data Input 3 I2S0_OUT_D0 I2S0 Serial Data Output 0 I2S0_OUT_D1 I2S0 Serial Data Output 1 I2S0_OUT_D2 I2S0 Serial Data Output 2 I2S0_OUT_D3 I2S0 Serial Data Output 3 I2S1_MCLK I2S1 Master Clock I2S1_SCLK I2S1 Serial Clock(BCLK) I2S1_WS I2S1 Word Select(LRCLK) I2S1_IN_D0 I2S1 Serial Data Input 0 I2S1_IN_D1 I2S1 Serial Data Input 1 I2S1_IN_D2 I2S1 Serial Data Input 2 I2S1_IN_D3 I2S1 Serial Data Input 3 I2S1_OUT_D0 I2S1 Serial Data Output 0 I2S1_OUT_D1 I2S1 Serial Data Output 1 I2S1_OUT_D2 I2S1 Serial Data Output 2 I2S1_OUT_D3 I2S1 Serial Data Output 3 I2S2_MCLK I2S2 Master Clock I2S2_SCLK I2S2 Serial Clock(BCLK) I2S2_WS I2S2 Word Select(LRCLK) I2S2_IN_D0 I2S2 Serial Data Input 0 I2S2_IN_D1 I2S2 Serial Data Input 1 I2S2_IN_D2 I2S2 Serial Data Input 2 I2S2_IN_D3 I2S2 Serial Data Input 3 I2S2_OUT_D0 I2S2 Serial Data Output 0 I2S2_OUT_D1 I2S2 Serial Data Output 1 I2S2_OUT_D2 I2S2 Serial Data Output 2 I2S2_OUT_D3 I2S2 Serial Data Output 3 RESV0 Reserved function RESV1 Reserved function RESV2 Reserved function RESV3 Reserved function RESV4 Reserved function RESV5 Reserved function I2C0_SCLK I2C0 Serial Clock I2C0_SDA I2C0 Serial Data I2C1_SCLK I2C1 Serial Clock I2C1_SDA I2C1 Serial Data I2C2_SCLK I2C2 Serial Clock I2C2_SDA I2C2 Serial Data CMOS_XCLK DVP System Clock CMOS_RST DVP System Reset CMOS_PWDN DVP Power Down Mode CMOS_VSYNC DVP Vertical Sync CMOS_HREF DVP Horizontal Reference output CMOS_PCLK Pixel Clock CMOS_D0 Data Bit 0 CMOS_D1 Data Bit 1 CMOS_D2 Data Bit 2 CMOS_D3 Data Bit 3 CMOS_D4 Data Bit 4 CMOS_D5 Data Bit 5 CMOS_D6 Data Bit 6 CMOS_D7 Data Bit 7 SCCB_SCLK SCCB Serial Clock SCCB_SDA SCCB Serial Data UART1_CTS UART1 Clear To Send UART1_DSR UART1 Data Set Ready UART1_DCD UART1 Data Carrier Detect UART1_RI UART1 Ring Indicator UART1_SIR_IN UART1 Serial Infrared Input UART1_DTR UART1 Data Terminal Ready UART1_RTS UART1 Request To Send UART1_OUT2 UART1 User-designated Output 2 UART1_OUT1 UART1 User-designated Output 1 UART1_SIR_OUT UART1 Serial Infrared Output UART1_BAUD UART1 Transmit Clock Output UART1_RE UART1 Receiver Output Enable UART1_DE UART1 Driver Output Enable UART1_RS485_EN UART1 RS485 Enable UART2_CTS UART2 Clear To Send UART2_DSR UART2 Data Set Ready UART2_DCD UART2 Data Carrier Detect UART2_RI UART2 Ring Indicator UART2_SIR_IN UART2 Serial Infrared Input UART2_DTR UART2 Data Terminal Ready UART2_RTS UART2 Request To Send UART2_OUT2 UART2 User-designated Output 2 UART2_OUT1 UART2 User-designated Output 1 UART2_SIR_OUT UART2 Serial Infrared Output UART2_BAUD UART2 Transmit Clock Output UART2_RE UART2 Receiver Output Enable UART2_DE UART2 Driver Output Enable UART2_RS485_EN UART2 RS485 Enable UART3_CTS UART3 Clear To Send UART3_DSR UART3 Data Set Ready UART3_DCD UART3 Data Carrier Detect UART3_RI UART3 Ring Indicator UART3_SIR_IN UART3 Serial Infrared Input UART3_DTR UART3 Data Terminal Ready UART3_RTS UART3 Request To Send UART3_OUT2 UART3 User-designated Output 2 UART3_OUT1 UART3 User-designated Output 1 UART3_SIR_OUT UART3 Serial Infrared Output UART3_BAUD UART3 Transmit Clock Output UART3_RE UART3 Receiver Output Enable UART3_DE UART3 Driver Output Enable UART3_RS485_EN UART3 RS485 Enable TIMER0_TOGGLE1 TIMER0 Toggle Output 1 TIMER0_TOGGLE2 TIMER0 Toggle Output 2 TIMER0_TOGGLE3 TIMER0 Toggle Output 3 TIMER0_TOGGLE4 TIMER0 Toggle Output 4 TIMER1_TOGGLE1 TIMER1 Toggle Output 1 TIMER1_TOGGLE2 TIMER1 Toggle Output 2 TIMER1_TOGGLE3 TIMER1 Toggle Output 3 TIMER1_TOGGLE4 TIMER1 Toggle Output 4 TIMER2_TOGGLE1 TIMER2 Toggle Output 1 TIMER2_TOGGLE2 TIMER2 Toggle Output 2 TIMER2_TOGGLE3 TIMER2 Toggle Output 3 TIMER2_TOGGLE4 TIMER2 Toggle Output 4 CLK_SPI2 Clock SPI2 CLK_I2C2 Clock I2C2 "},"libs/Maix/gpio.html":{"url":"libs/Maix/gpio.html","title":"GPIO","keywords":"","body":"GPIO General Purpose Input Output （通用输入/输出）简称为GPIO，或总线扩展器。 K210上有高速gpio和通用gpio 在 K210 上， GPIO 有一下特征： 高速 GPIO： 高速 GPIO 为 GPIOHS，共 32 个。具有如下特点： 可配置输入输出信号 每个 IO 具有独立中断源 中断支持边沿触发和电平触发 每个 IO 可以分配到 FPIOA 上 48 个管脚之一 可配置上下拉，或者高阻 通用 GPIO： 通用 GPIO 共 8 个，具有如下特点: 8 个 IO 使用一个中断源 可配置输入输出信号 可配置触发 IO 总中断，边沿触发和电平触发 每个 IO 可以分配到 FPIOA 上 48 个管脚之一 注意: 一下 GPIOHS 默认已经被使用， 程序中如非必要尽量不要使用： GPIOHS 功能 GPIOHS31 LCD_DC GPIOHS30 LCD_RST GPIOHS29 SD_CS GPIOHS28 MIC_LED_CLK GPIOHS27 MIC_LED_DATA 构造函数 class GPIO(ID,MODE,PULL,VALUE) 通过指定的参数新建一个 SPI 对象 参数 ID： 使用的GPIO引脚(一定要使用GPIO里带的常量来指定) MODE： GPIO模式 ​ • GPIO.IN就是输入模式 ​ • GPIO.OUT就是输出模式 PULL： GPIO上下拉模式 ​ • GPIO.PULL_UP 上拉 ​ • GPIO.PULL_DOWN 下拉 ​ • GPIO.PULL_NONE 即不上拉也不下拉 方法 value 修改/读取GPIO引脚状态 GPIO.value([value]) 参数 [value]： 可选参数，如果此参数不为空，则返回当前GPIO引脚状态 返回值 如果[value]参数不为空，则返回当前GPIO引脚状态 irq 配置一个中断处理程序，当pin的触发源处于活动状态时调用它。如果管脚模式为pin.in，则触发源是管脚上的外部值。 GPIO.irq(CALLBACK_FUNC,TRIGGER_CONDITION,GPIO.WAKEUP_NOT_SUPPORT,PRORITY) 参数 CALLBACK_FUNC：回调函数，当中断触发的时候被调用，他拥有两个参数，GPIO和PIN_NUM ​ • GPIO返回的是GPIO对象 ​ • PIN_NUM返回的是触发中断的GPIO引脚号(只有GPIOHS支持中断，所以这里的引脚号也是GPIOHS的引脚号) TRIGGER_CONDITION：当GPIO引脚处于这个状态时触发中断 ​ • GPIO.IRQ_RISING 上升沿触发 ​ • GPIO.IRQ_RISING 下降沿触发 ​ • GPIO.IRQ_BOTH 上升沿和下降沿都触发 返回值 无 disirq 关闭中断 GPIO.disirq() 参数 无 返回值 无 mode GPIO模式 GPIO.mode(MODE) 参数 MODE ​ • GPIO.IN就是输入模式 ​ • GPIO.OUT就是输出模式 返回值 无 pull GPIO上下拉模式 GPIO.pull(PULL) 参数 PULL ​ • GPIO.IRQ_RISING 上升沿触发 ​ • GPIO.IRQ_RISING 下降沿触发 ​ • GPIO.IRQ_BOTH 上升沿和下降沿都触发 返回值 无 常量 GPIO0: GPIO0 GPIO1: GPIO1 GPIO2: GPIO2 GPIO3: GPIO3 GPIO4: GPIO4 GPIO5: GPIO5 GPIO6: GPIO6 GPIO7: GPIO7 GPIOHS0: GPIOHS0 GPIOHS1: GPIOHS1 GPIOHS2: GPIOHS2 GPIOHS3: GPIOHS3 GPIOHS4: GPIOHS4 GPIOHS5: GPIOHS5 GPIOHS6: GPIOHS6 GPIOHS7: GPIOHS7 GPIOHS8: GPIOHS8 GPIOHS9: GPIOHS9 GPIOHS10: GPIOHS10 GPIOHS11: GPIOHS11 GPIOHS12: GPIOHS12 GPIOHS13: GPIOHS13 GPIOHS14: GPIOHS14 GPIOHS15: GPIOHS15 GPIOHS16: GPIOHS16 GPIOHS17: GPIOHS17 GPIOHS18: GPIOHS18 GPIOHS19: GPIOHS19 GPIOHS20: GPIOHS20 GPIOHS21: GPIOHS21 GPIOHS22: GPIOHS22 GPIOHS23: GPIOHS23 GPIOHS24: GPIOHS24 GPIOHS25: GPIOHS25 GPIOHS26: GPIOHS26 GPIOHS27: GPIOHS27 GPIOHS28: GPIOHS28 GPIOHS29: GPIOHS29 GPIOHS30: GPIOHS30 GPIOHS31: GPIOHS31 GPIO.IN: 输入模式 GPIO.OUT:输出模式 GPIO.PULL_UP:上拉 GPIO.PULL_DOWN:下拉 GPIO.PULL_NONE:即不上拉也不下拉 GPIO.IRQ_RISING:上升沿触发 GPIO.IRQ_RISING:下降沿触发 GPIO.IRQ_BOTH:上升沿和下降沿都触发 DEMO1 import utime from Maix import GPIO fm.register(board_info.LED_R,fm.fpioa.GPIO0) led_r=GPIO(GPIO.GPIO0,GPIO.OUT) utime.sleep_ms(500) led_r.value() fm.unregister(board_info.LED_R,fm.fpioa.GPIO0) DEMO2 import utime from Maix import GPIO fm.register(board_info.LED_R,fm.fpioa.GPIO0) led_r=GPIO(GPIO.GPIO0,GPIO.IN) utime.sleep_ms(500) led_r.value() fm.unregister(board_info.LED_R,fm.fpioa.GPIO0) DEMO3 import utime from Maix import GPIO def test_irq(GPIO,pin_num): print(\"key\",pin_num,\"\\n\") fm.register(board_info.BOOT_KEY,fm.fpioa.GPIOHS0) key=GPIO(GPIO.GPIOHS0,GPIO.IN,GPIO.PULL_NONE) utime.sleep_ms(500) key.value() key.irq(test_irq,GPIO.IRQ_BOTH,GPIO.WAKEUP_NOT_SUPPORT,7) key.disirq() fm.unregister(board_info.BOOT_KEY,fm.fpioa.GPIOHS0) "},"libs/Maix/kpu.html":{"url":"libs/Maix/kpu.html","title":"KPU","keywords":"","body":"KPU KPU是通用的神经网络处理器，它可以在低功耗的情况下实现卷积神经网络计算，时时获取被检测目标的大小、坐标和种类，对人脸或者物体进行检测和分类。 KPU 具备以下几个特点： 支持主流训练框架按照特定限制规则训练出来的定点化模型 对网络层数无直接限制，支持每层卷积神经网络参数单独配置，包括输入输出通道数目、输入输 出行宽列高 支持两种卷积内核 1x1 和 3x3 支持任意形式的激活函数 实时工作时最大支持神经网络参数大小为 5.5MiB 到 5.9MiB 非实时工作时最大支持网络参数大小为（Flash 容量-软件体积） 模块方法 加载模型 从flash或者文件系统中加载模型 import KPU as kpu task = kpu.load(offset or file_path) 参数 offtset: 模型在 flash 中的偏移大小，如 0xd00000 表示模型烧录在13M起始的地方 file_path: 模型在文件系统中为文件名， 如 “/sd/xxx.kmodel” 返回 kpu_net: kpu 网络对象 初始化yolo2网络 为yolo2网络模型传入初始化参数 import KPU as kpu task = kpu.load(offset or file_path) anchor = (1.889, 2.5245, 2.9465, 3.94056, 3.99987, 5.3658, 5.155437, 6.92275, 6.718375, 9.01025) kpu.init_yolo2(task, 0.5, 0.3, 5, anchor) 参数 kpu_net: kpu 网络对象 threshold: 概率阈值 nms_value: box_iou 门限 anchor_num: 锚点数 anchor: 锚点参数与模型参数一致 反初始化 import KPU as kpu task = kpu.load(offset or file_path) kpu.deinit(task) 参数 kpu_net: kpu_load 返回的 kpu_net 对象 运行yolo2网络 import KPU as kpu import image task = kpu.load(offset or file_path) anchor = (1.889, 2.5245, 2.9465, 3.94056, 3.99987, 5.3658, 5.155437, 6.92275, 6.718375, 9.01025) kpu.init_yolo2(task, 0.5, 0.3, 5, anchor) img = image.Image() kpu.run_yolo2(task, img) #此处不对，请参考例程 参数 kpu_net: kpu_load 返回的 kpu_net 对象 image_t：从 sensor 采集到的图像 返回 list: kpu_yolo2_find 的列表 网络前向运算(forward) 计算已加载的网络模型到指定层数，输出目标层的特征图 import KPU as kpu task = kpu.load(offset or file_path) …… fmap=kpu.forward(task,img,3) 参数 kpu_net: kpu_net 对象 image_t: 从 sensor 采集到的图像 int: 指定计算到网络的第几层 返回 fmap: 特征图对象，内含当前层所有通道的特征图 fmap 特征图 取特征图的指定通道数据到image对象 img=kpu.fmap(fmap,1) 参数 fmap: 特征图 对象 int: 指定特征图的通道号 返回 img_t: 特征图对应通道生成的灰度图 fmap_free 释放特征图 释放特征图对象 kpu.fmap_free(fmap) 参数 fmap: 特征图 对象 返回 无 netinfo 获取模型的网络结构信息 info=kpu.netinfo(task) layer0=info[0] 参数 kpu_net: kpu_net 对象 返回 netinfo list：所有层的信息list, 包含信息为：index：当前层在网络中的层数 wi：输入宽度 hi：输入高度 wo：输出宽度 ho：输出高度 chi：输入通道数 cho：输出通道数 dw：是否为depth wise layer kernel_type：卷积核类型，0为1x1， 1为3x3 pool_type：池化类型，0不池化; 1：2x2 max pooling; 2:... para_size：当前层的卷积参数字节数 例程 运行人脸识别demo 模型下载地址：http://dl.sipeed.com/MAIX/MaixPy/model/face_model_at_0x300000.kfpkg import sensor import image import lcd import KPU as kpu lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) task = kpu.load(0x300000) #使用kfpkg将 kmodel 与 maixpy 固件打包下载到 flash anchor = (1.889, 2.5245, 2.9465, 3.94056, 3.99987, 5.3658, 5.155437, 6.92275, 6.718375, 9.01025) a = kpu.init_yolo2(task, 0.5, 0.3, 5, anchor) while(True): img = sensor.snapshot() code = kpu.run_yolo2(task, img) if code: for i in code: print(i) a = img.draw_rectangle(i.rect()) a = lcd.display(img) a = kpu.deinit(task) 运行特征图 模型下载地址：http://dl.sipeed.com/MAIX/MaixPy/model/face_model_at_0x300000.kfpkg 该模型是8bit定点模型，约380KB大小，层信息为： 1 2 :160x120 3 4 5 6 :80x60 7 8 9 10 :40x30 11~16 :20x15 import sensor import image import lcd import KPU as kpu index=3 lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) task=kpu.load(0x300000) img=image.Image() info=kpu.netinfo(task) layer=info[index] w=layer.wo() h=layer.ho() num=int(320*240/w/h) list=[None]*num x_step=int(320/w) y_step=int(240/h) img_lcd=image.Image() while True: img=sensor.snapshot() fmap=kpu.forward(task,img,index) for i in range(0,num): list[i]=kpu.fmap(fmap,i) for i in range(0,num): list[i].stretch(64,255) for i in range(0,num): a=img_lcd.draw_image(list[i],((i%x_step)*w,(int(i/x_step))*h)) lcd.display(img_lcd) kpu.fmap_free(fmap) "},"libs/Maix/fft.html":{"url":"libs/Maix/fft.html","title":"FFT","keywords":"","body":"FFT运算 FFT快速傅里叶变换模块，对输入数据进行傅里叶变换并返回相应的频率幅值, FFT快速傅里叶运算可以将时域信号转换为频域信号 模块函数 运算函数 输入时域数据并进行傅里叶变换 import FFT res = FFT.run(data, points, shift) 参数 data: 输入的时域数据，bytearray类型 points: FFT运算点数，仅支持64, 128，256和512点 shift: 偏移，默认为0 返回值 res: 返回计算后的频域数据，以list类型呈现，该列表有points个元组，每个元组有 2 个元素，第一个元素为实部，第二个为虚部 频率函数 FFT res = FFT.freq(points, sample_rate) 参数 points: 计算点数 sample_rate: 采样率 返回值 res : 返回一个列表，该列表存放的进行运算后后所有频率点的频率值 幅值函数 用于计算 FFT 运算后的各个频率点的幅值，目前用作测试，用户可以自己在python自行写幅值处理函数 amp = FFT.amplitude(FFT_res) 参数 FFT_res: 函数 run 运行后的结果 返回值 res : 返回一个列表，该列表存放了各个频率点的幅值 例程 采集声音并进行FFT运算，将运算后的数据在屏幕上显示为柱状图 例示代码： https://github.com/sipeed/MaixPy_scripts/blob/master/hardware/demo_fft_spectrum.py "},"libs/builtin_py/":{"url":"libs/builtin_py/","title":"内置类","keywords":"","body":"内置类 内置类 库是对MaixPy底层的类进行封装的用户层接口，方便用户使用MaixPy，它包括以下： fpioa_manager board_info 需要注意的是， 这些类在开机启动的时候在 _boot.py 里面已经被导入了， 所以在串口终端可以直接使用， 但是， 如果是执行文件， 则需要手动写代码导入， 否则找不到类 from board import board_info from fpioa_manager import fm 或者 只导入 from fpioa_manager import fm, board_info "},"libs/builtin_py/fm.html":{"url":"libs/builtin_py/fm.html","title":"fpioa_manager","keywords":"","body":"fpioa_manager fpioa_manager：简称fm，该模块用于注册芯片内部功能和引脚，帮助用户管理内部功能和引脚，如果功能和引脚已经被注册，将无法使用该内部功能和引脚。 fm 实际上是使用 Fpioa_Manager 类定义的一个对象， 使用 Micropython 编写并集成带固件中， 源码看 fpioa_manager.py 方法 注册函数 注册引脚和功能 fm.register(pin,function) 参数 该方法必须传入2个参数，不然将返回空值 pin: 功能映射引脚 function : 芯片功能 返回值 该方法具有2个返回值， 参数错误返回 None,None 设置成功返回 pin,function 设置失败返回 reg_pin,reg_func，表示的是已经被注册的引脚和功能 注销函数 注销引脚和功能 fm.unregister(pin,function) 参数 该方法可以传入1或2个参数，当传入1个参数时，需要添加参数关键字。如果为1个参数，其引脚和功能都将被注销 pin: 功能映射引脚 function : 芯片功能 返回值 参数错误返回 None,None 设置成功返回 pin,function，表示被注销的引脚和功能 设置失败返回 0,0 例程 from fpioa_manager import fm, board_info fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX) fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX)#再注册一次 fm.register(board_info.WIFI_RX,fm.fpioa.SPI0_SS0)#注册同个引脚 fm.register(board_info.WIFI_RX,fm.fpioa.SPI0_SS0)#注册同个功能 fm.unregister(board_info.WIFI_RX,fm.fpioa.UART2_TX)#注销功能和引脚 fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX) fm.unregister(function = fm.fpioa.UART2_TX)#注销功能 fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX) fm.unregister(pin = board_info.WIFI_RX)#注销引脚 附录 以下引脚已经在MaxiPy开机启动时注册，请用户注意 SD卡 功能：SPI1_SCLK/SPI1_D0/SPI1_D1/GPIOHS7/SPI0_SS1 引脚：PIN25/PIN26/PIN27/PIN28/PIN29 LCD 功能：SPI0_SS3/SPI0_SCLK/GPIOHS1/GPIOHS2 引脚：PIN36/PIN37/PIN38/PIN39 sensor 功能：SCCB_SDA/SCCB_SCLK/CMOS_RST/CMOS_VSYNC/CMOS_PWDN/CMOS_HREF/CMOS_XCLK/CMOS_PCLK 引脚：PIN40/PIN41/PIN42/PIN43/PIN44/PIN45/PIN46/PIN47 REPL 功能：UARTHS_RX/UARTHS_TX 引脚：PIN4/PIN5 "},"libs/builtin_py/board_info.html":{"url":"libs/builtin_py/board_info.html","title":"board_info","keywords":"","body":"board_info board_info：主要用于方便用户使用开发板引脚配置，其中内置了对人友好的命名及接口，可以使用户减少对电器连接原理图的依赖。 board_info 是内部定义的一个 Board_Info 全局变量， 使用 MicroPython 语法编写， 源码见 board.py 成员 board_info拥有许多个引脚索引和一个列表 pin_name列表 列表主要是用于类内部使用，用户不对其进行操作 引脚索引 引脚索引主要是将数字转换为人类友好的字符串，让用户方便编程 输入以下，请注意不要忽略 . 号，然后按下 tab键 进行补全，可以看到板级相关的引脚功能 board_info. 比如输入以下代码，将返回数字 8，代表的是开发板的第8号引脚，其电器连接是wifi模块的使能引脚 board_info.WIFI_EN 方法 查找方法 当用户不清楚引脚电器连接时，可以使用该方法查找 board_info.pin_map(pin_num) 参数 该方法不传入参数或者传入一个参数 pin_num: 引脚编号，范围[6,47] 当不传入参数时，将打印所有引脚的板级电气连接信息 传入参数时，仅打印指定引脚的板级电气连接信息 返回值 参数错误返回 False 未知错误返回 False 查找成功返回 信息 例程 例程 1 from board import board_info wifi_en_pin = board_info.WIFI_EN print(wifi_en_pin)#输出为8 board_info.pin_map()#打印所有 board_info.pin_map(8)#只打印8号引脚的信息 "},"libs/machine_vision/":{"url":"libs/machine_vision/","title":"机器视觉","keywords":"","body":"机器视觉 主要包含了了与图像、显示相关的类，包括： lcd sensor image "},"libs/machine_vision/lcd.html":{"url":"libs/machine_vision/lcd.html","title":"lcd","keywords":"","body":"lcd 屏幕显示驱动 函数 lcd.init(type=1, freq=15000000, color=lcd.BLACK) 初始化 LCD 屏幕显示 参数 type： LCD 的类型（保留给未来使用）: 0: None 1: lcd shield（默认值） type 是键值参数，必须在函数调用中通过写入 type= 来显式地调用 freq： LCD （实际上指 SPI 的通讯速率） 的频率 color： LCD 初始化的颜色， 可以是 16 位的 RGB565 颜色值，比如 0xFFFF； 或者 RGB888 元组， 比如 (236, 36, 36)， 默认 lcd.BLACK lcd.deinit() 注销 LCD 驱动，释放I/O引脚 lcd.width() 返回 LCD 的宽度（水平分辨率） lcd.height() 返回 LCD 的高度（垂直分辨率）。 lcd.type() 返回 LCD 的类型（保留给未来使用）： 0: None 1: lcd Shield lcd.freq(freq) 设置或者获取 LCD （SPI） 的频率 Paremeters freq: LCD (SPI) 的频率 Return LCD 的频率 lcd.set_backlight(state) 设置 LCD 的背光状态， 关闭背光会大大降低lcd扩展板的能耗 //TODO: 未实现 参数 state： 背光亮度， 取值 [0,100] lcd.get_backlight() 返回背光状态 返回值 背光亮度， 取值 [0,100] lcd.display(image, roi=Auto) 在液晶屏上显示一张 image（GRAYSCALE或RGB565）。 roi 是一个感兴趣区域的矩形元组(x, y, w, h)。若未指定，即为图像矩形 若 roi 宽度小于lcd宽度，则用垂直的黑色边框使 roi 居于屏幕中心（即用黑色填充未占用区域）。 若 roi 宽度大于lcd宽度，则 roi 居于屏幕中心，且不匹配像素不会显示（即液晶屏以窗口形态显示 roi 的中心）。 若 roi 高度小于lcd高度，则用垂直的黑色边框使 roi 居于屏幕中心（即用黑色填充未占用区域）。 若 roi 高度大于lcd高度，则 roi 居于屏幕中心，且不匹配像素不会显示（即液晶屏以窗口形态显示 roi 的中心）。 roi 是键值参数，必须在函数调用中通过写入 roi= 来显式地调用。 lcd.clear() 将液晶屏清空为黑色或者指定的颜色。 参数 color： LCD 初始化的颜色， 可以是 16 位的 RGB565 颜色值，比如 0xFFFF； 或者 RGB888 元组， 比如 (236, 36, 36) lcd.direction(dir) 在 v0.3.1 之后已经被舍弃， 请使用lcd.rotation 和 lcd.invert代替， 如非必要请勿使用， 接口仍会被保留用于调试使用 设置屏幕方向， 以及是否镜像等 参数 dir： 正常情况下推荐 lcd.YX_LRUD 和 lcd.YX_RLDU， 另外还有其它值，交换 XY 或者 LR 或者 DU即可 lcd.rotation(dir) 设置 LCD 屏幕方向 参数 dir: 取值范围 [0,3]， 从0到3依次顺时针旋转 返回值 当前方向，取值[0,3] lcd.mirror(invert) 设置 LCD 是否镜面显示 参数 invert： 是否镜面显示， True 或者 False 返回值 当前设置，是否镜面显示，返回True或者False 例程 例程 1： 显示英文 import lcd lcd.init() lcd.draw_string(100, 100, \"hello maixpy\", lcd.RED, lcd.BLACK) 例程 2： 显示图片 import lcd import image img = image.Image(\"/sd/pic.bmp\") lcd.display(img) 例程 3： 利用显示图片的方式显示英文 import lcd import image img = image.Image() img.draw_string(60, 100, \"hello maixpy\", scale=2) lcd.display(img) 例程 4： 实时显示摄像头捕捉到的图像 import sensor, lcd sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) sensor.skip_frames() lcd.init() while(True): lcd.display(sensor.snapshot()) "},"libs/machine_vision/sensor.html":{"url":"libs/machine_vision/sensor.html","title":"sensor","keywords":"","body":"sensor 传感器模块，进行摄像头配置及图像抓取等，用于控制开发板摄像头完成摄像任务。 方法 单目摄像头重置函数 重置并初始化摄像头。这里会自动扫描并获取摄像头地址 sensor.reset() #初始化单目摄像头 参数 无 返回值 无 双目摄像头重置函数 芯片只有一个dvp接口，所以通过pwdn引脚来选择sensor。pwdn引脚可以通过shutdown接口来控制。指定sensor后其余操作不变。详细请见例程2 sensor.binocular_reset()#初始化双目摄像头 参数 无 返回值 无 启动函数 启动/关闭芯片捕获图像 sensor.run(enable) 参数 enable: 1表示开启，0 表示停止 返回值 return: 返回1 设置帧大小 用于设置摄像头输出帧大小，k210最大支持VGA格式，大于VGA将无法获取图像。 MaixPy开发板配置的屏幕是320*240分辨率，推荐设置为QVGA格式 sensor.set_framesize(framesize) 参数 framesize: 帧大小 返回值 True : 设置成功 False: 设置错误 设置帧格式 用于设置摄像头输出格式，k210支持rgb565和yuv422格式。MaixPy开发板配置的屏幕是使用rgb565设置，推荐设置为RGB565格式 sensor.set_pixformat(format) 参数 format: 帧格式 返回值 True : 设置成功 False: 设置错误 开始图像捕捉 开启图像捕捉功能 sensor.run(enable) 参数 enable: 1 表示开始抓取图像 0 表示停止抓取图像 返回值 True : 设置成功 False: 设置错误 获取图像 控制摄像头捕捉图像 img = sensor.snapshot() 参数 无 返回值 img: 返回的图像对象 关闭摄像头 关闭摄像头/切换摄像头 sensor.shutdown(enable/select) 参数 单目摄像头 enable: 1 表示开启摄像头 0 表示关闭摄像头 双目摄像头 select: 通过写入0或1来切换摄像头 返回值 无 跳帧 跳过指定帧数或者跳过指定时间内的图像 sensor.skip_frames([n,time]) 参数 n: 跳过 n 帧图像 time: 跳过指定时间，单位为ms 返回值 无 分辨率宽度 获取摄像头分辨率宽度 sensor.width() 参数 无 返回值 int类型的摄像头分辨率宽度 分辨率高度 sensor.height() 参数 无 返回值 int类型的摄像头分辨率高度 获取帧缓冲 获取当前帧缓冲区 sensor.get_fb() 参数 无 返回值 image类型的对象 获取ID 获取当前摄像头ID sensor.get_id() 参数 无 返回值 int类型的ID 设置彩条模式 将摄像头设置为彩条模式 sensor.set_colorbar(enable) 参数 enable: 1 表示开启彩条模式 0 表示关闭彩条模式 返回值 无 设置对比度 设置摄像头对比度 sensor.set_contrast(contrast) 参数 constrast: 摄像头对比度，范围为[-2,+2] 返回值 True : 设置成功 False: 设置错误 设置亮度 设置摄像头亮度 sensor.set_brightness(brightness) 参数 constrast: 摄像头亮度，范围为[-2,+2] 返回值 True : 设置成功 False: 设置错误 设置饱和度 设置摄像头饱和度 sensor.set_saturation(saturation) 参数 constrast: 摄像头饱和度，范围为[-2,+2] 返回值 True : 设置成功 False: 设置错误 设置自动增益 设置摄像自动增益模式 sensor.set_auto_gain(enable,gain_db) 参数 enable: 1 表示开启自动增益 0 表示关闭自动增益 gain_db: 关闭自动增益时，设置的摄像头固定增益值，单位为db 返回值 无 获取增益值 获取摄像头增益值 sensor.get_gain_db() 参数 无 返回值 float类型的增益值 设置水平镜像 设置摄像头水平镜像 sensor.set_hmirror(enable) 参数 enable: 1 表示开启水平镜像 0 表示关闭水平镜像 返回值 无 写入寄存器 往摄像头寄存器写入指定值 sensor.__write_reg(address, value) 参数 address: 寄存器地址 value ： 写入值 返回值 无 读取寄存器 读取摄像头寄存器值 sensor.__read_reg(address) 参数 address: 寄存器地址 返回值 int类型的寄存器值 例程 例程 1 import sensor import lcd lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) while 1: img = sensor.snapshot() lcd.display(img) 例程 2 import sensor import image import lcd import time lcd.init() sensor.binocular_reset() sensor.shutdown(False)#选择sensor并初始化 sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.shutdown(True)#选择sensor并初始化 sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) while True: sensor.shutdown(False) #选择sensor img=sensor.snapshot() lcd.display(img) time.sleep_ms(100) sensor.shutdown(True) #选择sensor img=sensor.snapshot() lcd.display(img) time.sleep_ms(100) "},"libs/machine_vision/image.html":{"url":"libs/machine_vision/image.html","title":"image","keywords":"","body":"image — 机器视觉 移植于 openmv， 与 openmv 功能相同 例程 例程 1： 找绿色 import sensor import image import lcd import time lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) green_threshold = (0, 80, -70, -10, -0, 30) while True: img=sensor.snapshot() blobs = img.find_blobs([green_threshold]) if blobs: for b in blobs: tmp=img.draw_rectangle(b[0:4]) tmp=img.draw_cross(b[5], b[6]) c=img.get_pixel(b[5], b[6]) lcd.display(img) 例程 2： 显示 fps import sensor import image import lcd import time clock = time.clock() lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) sensor.skip_frames(30) while True: clock.tick() img = sensor.snapshot() fps =clock.fps() img.draw_string(2,2, (\"%2.1ffps\" %(fps)), color=(0,128,0), scale=2) lcd.display(img) 例程 3： 扫描二维码 import sensor import image import lcd import time clock = time.clock() lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.set_vflip(1) sensor.run(1) sensor.skip_frames(30) while True: clock.tick() img = sensor.snapshot() res = img.find_qrcodes() fps =clock.fps() if len(res) > 0: img.draw_string(2,2, res[0].payload(), color=(0,128,0), scale=2) print(res[0].payload()) lcd.display(img) 如果使用了镜头，画面会有扭曲，需要矫正画面 使用 lens_corr 函数来矫正， 比如 2.8mm， img.lens_corr(1.8) 函数 函数还可以在本页按 Ctrl+F 使用浏览器的搜索功能搜 image. 来标记函数 image.rgb_to_lab(rgb_tuple) 返回RGB888格式的元组 rgb_tuple (r, g, b)对应的LAB格式的元组(l, a, b)。 RGB888是指红、绿、蓝各8位（0-255）。在LAB中，L的取值范围为0-100，a/b 的取值范围为-128到127。 image.lab_to_rgb(lab_tuple) 返回LAB格式的元组 lab_tuple (l, a, b)对应的RGB888格式的元组(r, g, b)。 RGB888是指红、绿、蓝各8位（0-255）。在LAB中，L的取值范围为0-100，a/b 的取值范围为-128到127。 image.rgb_to_grayscale(rgb_tuple) 返回RGB888格式的元组 rgb_tuple (r, g, b)对应的灰度值。 RGB888是指红、绿、蓝各8位（0-255）。灰度值取值于0-255。 image.grayscale_to_rgb(g_value) 返回灰度值 g_value 对应的RGB888格式的元组(r, g, b)。 RGB888是指红、绿、蓝各8位（0-255）。灰度值取值于0-255。 image.load_decriptor(path) 从磁盘上加载一个描述符对象(descriptor object). path 是描述符文件保存的路径。 image.save_descriptor(path, descriptor) 保存描述符对象 descriptor 到磁盘。 path 是描述符文件保存的路径。 image.match_descriptor(descritor0, descriptor1[, threshold=70[, filter_outliers=False]]) 对于LBP描述符来说，这个函数返回的是一个体现两个描述符之间区别的整数。这一距离测度尤为必要。这个距离是对相似度的一个度量。这个测度值越接近0，LBPF特征点匹配得就越好。 对于ORB描述符来说，这个函数返回的是kptmatch对象。见上。 threshold 是用来为ORB键点过滤不明确匹配服务的。 一个较低的 threshold 值将紧扣关键点匹配算法。 threshold 值位于0-100 (int)。默认值为70。 filter_outliers 是用来为ORB键点过滤异常值服务的。 特征点允许用户提高 threshold 值。默认设置为False。 HaarCascade 类 – 特征描述符 Haar Cascade特征描述符用于 image.find_features() 方法。它没有供用户调用的方法。 构造函数 class image.HaarCascade(path[, stages=Auto]) 从一个Haar Cascade二进制文件\b（适合OpenMV Cam\b的格式）加载一个Haar Cascade。 如果您传递“frontalface”字符串 而非一条路径，这个构造函数将会把一个内置的正脸Haar Cascade载入内存。 此外，您也可以通过“eye”来把Haar Cascade载入内存。 最后，这个方法会返回载入的Haar Cascade对象，用来使用 image.find_features() 。 stages 默认值为Haar Cascade中的阶段数。然而，您可以指定一个较低的数值来加速运行特征检测器，当然这会带来较高的误报率。 您可以制作自己的Haar Cascades 来配合您的OpenMV Cam 使用。 首先，使用谷歌搜索“ Haar Cascade”，检测是否有人已经为您想要检测的对象制作了OpenCV Haar Cascade。 如果没有，那您需要自己动手制作（工作量巨大）。 关于如何制作自己的Haar Cascade，见此 关于如何把OpenCV Haar Cascades转化成您的OpenMV Cam可以读取的模式， 见此script 问：Haar Cascade 是什么？ 答：Haar Cascade是一系列用来确定一个对象是否存在于图像中的对比检查。 这一系列的对比检查分成了多个阶段，后一阶段的运行以先前阶段的完成为前提。 对比检查并不复杂，不过是像检查图像的中心垂直是否比边缘更轻微之类的过程。 大范围的检查在前期阶段首先进行，在后期进行更多更小的区域检查。 问：Haar Cascades 是如何制作而成的？ 答：Haar Cascades通过标有正负的图像对发生器算法进行训练。 比如，用数百张含有猫（已被标记为内含猫）的图片和数百张不含有猫形物的图片（已作出不同标记）来训练这个生成算法。 \b\b这个生成算法\b最后会产生一个用来检测猫的Haar Cascades。 Similarity 类 – 相似度对象 相似度对象由 image.get_similarity 返回. 构造函数 class image.similarity 请调用 image.get_similarity() 函数来创建此对象。 方法 similarity.mean() 返回8x8像素块结构相似性差异的均值。范围[-1/+1]，其中 -1完全不同，+1完全相同。 您也可以通过索引 [0] 取得这个值。 similarity.stdev() 返回8x8像素块结构相似性差异的标准偏差。 您也可以通过索引 [1] 取得这个值。 similarity.min() 返回8x8像素块结构相似性差异的最小值。其中 -1完全不同，+1完全相同。 您也可以通过索引 [2] 取得这个值。 通过查看此值，您可以快速确定两个图像之间的任何8x8像素块是否差别很大，即远远低于+1。 similarity.max() 返回8x8像素块结构相似性差异的最小值。其中 -1完全不同，+1完全相同。 您也可以通过索引 [3] 取得这个值。 通过查看此值，您可以快速确定两个图像之间的任何8x8像素块是否都相同。即比-1大很多。 Histogram 类 – 直方图对象 直方图对象是由 image.get_histogram 返回。 灰度直方图有一个包含多个二进制的通道。 所有二进制都进行标准化，使其总和为1。 RGB565有三个包含多个二进制的通道。所有二进制都进行标准化，使其总和为1。 构造函数 class image.histogram 请调用 image.get_histogram() 函数来创建此对象。 方法 histogram.bins() 返回灰度直方图的浮点数列表。 您也可以通过索引 [0] 取得这个值。 histogram.l_bins() 返回RGB565直方图LAB的L通道的浮点数列表。 您也可以通过索引 [0] 取得这个值。 histogram.a_bins() 返回RGB565直方图LAB的A通道的浮点数列表。 您也可以通过索引 [1] 取得这个值。 histogram.b_bins() 返回RGB565直方图LAB的B通道的浮点数列表。 您也可以通过索引 [2] 取得这个值。 histogram.get_percentile(percentile) 计算直方图频道的CDF，返回一个传递 percentile (0.0 - 1.0) (浮点数)中的直方图的值。 因此，若您传入0.1，该方法会告知您，当累加入累加器时，哪一个二进制会使累加器跨过0.1。 在没有异常效用破坏您的自适应色跟踪结果时，这对于确定颜色分布的最小值(0.1)和max(0.9)甚是有效。 histogram.get_threhsold() 使用Otsu’s 方法计算最佳阈值，将直方图分的每个通道为两半。 该方法返回一个 image.threshold 对象。 这个方法对确定最佳的 image.binary() 阈值特别有用。 histogram.get_statistics() 计算直方图中每个颜色通道的平均值、中值、众值、标准差、最小值、最大值、下四分值和上四分值， 并返回一个statistics对象。 您也可以使用 histogram.statistics() 和 histogram.get_stats() 作为这个方法的别名。 Percentile 类 – 百分比\b值对象 百分比值对象由 histogram.get_percentile 返回。 灰度百分比值有一个通道。不使用 l* 、 a 或 b_ 方法。 RGB565百分比值有三个通道。使用 l* 、 a 和 b_ 方法。 构造函数 class image.percentile 请调用 histogram.get_percentile() 函数来创建此对象。 方法 percentile.value() 返回灰度百分比值（取值区间为0-255）。 您也可以通过索引 [0] 取得这个值。 percentile.l_value() 返回RGB565 LAB 的L通道的百分比值（取值区间为0-100）。 您也可以通过索引 [0] 取得这个值。 percentile.a_value() 返回RGB565 LAB 的A通道的百分比值（取值区间为-128-127）。 您也可以通过索引 [1] 取得这个值。 percentile.b_value() 返回RGB565 LAB 的B通道的百分比值（取值区间为-128-127）。 您也可以通过索引 [2] 取得这个值。 Threhsold 类 – 阈值对象 阈值对象由 histogram.get_threshold 返回。 灰度图像有一个通道。没有 l*, a, 和 b_ 方法. RGB565 阈值有三个通道。使用 l*, a, 和 b_ 方法。 构造函数 class image.threshold 请调用 histogram.get_threshold() 函数来创建此对象。 方法 threhsold.value() 返回灰度图的阈值 (between 0 and 255)。 您也可以通过索引 [0] 取得这个值。 threhsold.l_value() 返回RGB565图LAB中的L阈值 (between 0 and 100). 您也可以通过索引 [0] 取得这个值。 threhsold.a_value() 返回RGB565图LAB中的A阈值 (between -128 and 127). 您也可以通过索引 [1] 取得这个值。 threhsold.b_value() 返回RGB565图LAB中的B阈值 (between -128 and 127). 您也可以通过索引 [2] 取得这个值。 class Statistics – 统计数据对象 统计数据对象是由 histogram.get_statistics 或 image.get_statistics 返回的。 灰度统计数据有一个通道，使用非 l* 、 a 或 b_ 方法。 RGB565百分比值有三个通道。使用 l* 、 a 和 b_ 方法。 构造函数 class image.statistics 请调用 histogram.get_statistics() 或 image.get_statistics() 函数来创建此对象。 方法 statistics.mean() 返回灰度均值(0-255) (int)。 您也可以通过索引 [0] 取得这个值。 statistics.median() 返回灰度中值(0-255) (int)。 您也可以通过索引 [1] 取得这个值。 statistics.mode() 返回灰度众值(0-255) (int)。 您也可以通过索引 [2] 取得这个值。 statistics.stdev() 返回灰度标准差(0-255) (int)。 您也可以通过索引 [3] 取得这个值。 statistics.min() 返回灰度最小值(0-255) (int)。 您也可以通过索引 [4] 取得这个值。 statistics.max() 返回灰度最大值(0-255) (int)。 您也可以通过索引 [5] 取得这个值。 statistics.lq() 返回灰度下四分值(0-255) (int)。 您也可以通过索引 [6] 取得这个值。 statistics.uq() 返回灰度上四分值(0-255) (int)。 您也可以通过索引 [7] 取得这个值。 statistics.l_mean() 返回RGB5656 LAB 中L的均值(0-255) (int)。 您也可以通过索引 [0] 取得这个值。 statistics.l_median() 返回RGB5656 LAB 中L的中值(0-255) (int)。 您也可以通过索引 [1] 取得这个值。 statistics.l_mode() 返回RGB5656 LAB 中L的众值(0-255) (int)。 您也可以通过索引 [2] 取得这个值。 statistics.l_stdev() 返回RGB5656 LAB 中L的标准偏差值(0-255) (int)。 您也可以通过索引 [3] 取得这个值。 statistics.l_min() 返回RGB5656 LAB 中L的最小值(0-255) (int)。 您也可以通过索引 [4] 取得这个值。 statistics.l_max() 返回RGB5656 LAB 中L的最大值(0-255) (int)。 您也可以通过索引 [5] 取得这个值。 statistics.l_lq() 返回RGB5656 LAB 中L的下四分值(0-255) (int)。 您也可以通过索引 [6] 取得这个值。 statistics.l_uq() 返回RGB5656 LAB 中L的上四分值(0-255) (int)。 您也可以通过索引 [7] 取得这个值。 statistics.a_mean() 返回RGB5656 LAB 中A的均值(0-255) (int)。 您也可以通过索引 [8] 取得这个值。 statistics.a_median() 返回RGB5656 LAB 中A的中值(0-255) (int)。 您也可以通过索引 [9] 取得这个值。 statistics.a_mode() 返回RGB5656 LAB 中A的众值(0-255) (int)。 您也可以通过索引 [10] 取得这个值。 statistics.a_stdev() 返回RGB5656 LAB 中A的标准偏差值(0-255) (int)。 您也可以通过索引 [11] 取得这个值。 statistics.a_min() 返回RGB5656 LAB 中A的最小值(0-255) (int)。 您也可以通过索引 [12] 取得这个值。 statistics.a_max() 返回RGB5656 LAB 中A的最大值(0-255) (int)。 您也可以通过索引 [13] 取得这个值。 statistics.a_lq() 返回RGB5656 LAB 中A的下四分值(0-255) (int)。 您也可以通过索引 [14] 取得这个值。 statistics.a_uq() 返回RGB5656 LAB 中A的上四分值(0-255) (int)。 您也可以通过索引 [15] 取得这个值。 statistics.b_mean() 返回RGB5656 LAB 中B的均值(0-255) (int)。 您也可以通过索引 [16] 取得这个值。 statistics.b_median() 返回RGB5656 LAB 中B的中值(0-255) (int)。 您也可以通过索引 [17] 取得这个值。 statistics.b_mode() 返回RGB5656 LAB 中B的众值(0-255) (int)。 您也可以通过索引 [18] 取得这个值。 statistics.b_stdev() 返回RGB5656 LAB 中B的标准差值(0-255) (int)。 您也可以通过索引 [19] 取得这个值。 statistics.b_min() 返回RGB5656 LAB 中B的最小值(0-255) (int)。 您也可以通过索引 [20] 取得这个值。 statistics.b_max() 返回RGB5656 LAB 中B的最大值(0-255) (int)。 您也可以通过索引 [21] 取得这个值。 statistics.b_lq() 返回RGB5656 LAB 中B的下四分值(0-255) (int)。 您也可以通过索引 [22] 取得这个值。 statistics.b_uq() 返回RGB5656 LAB 中B的上四分值(0-255) (int)。 您也可以通过索引 [23] 取得这个值。 Blob 类 – 色块对象 色块对象是由 image.find_blobs 返回的。 构造函数 class image.blob 请调用 image.find_blobs() 函数来创建此对象。 方法 blob.rect() 返回一个矩形元组(x, y, w, h) ，用于如色块边界框的 image.draw_rectangle 等 其他的 image 方法。 blob.x() 返回色块的边界框的x坐标(int)。 您也可以通过索引 [0] 取得这个值。 blob.y() 返回色块的边界框的y坐标(int)。 您也可以通过索引 [1] 取得这个值。 blob.w() 返回色块的边界框的w坐标(int)。 您也可以通过索引 [2] 取得这个值。 blob.h() 返回色块的边界框的h坐标(int)。 您也可以通过索引 [3] 取得这个值。 blob.pixels() 返回从属于色块(int)一部分的像素数量。 您也可以通过索引 [4] 取得这个值。 blob.cx() 返回色块(int)的中心x位置。 您也可以通过索引 [5] 取得这个值。 blob.cy() 返回色块(int)的中心x位置。 您也可以通过索引 [6] 取得这个值。 blob.rotation() 返回色块的旋转（单位：弧度）。如果色块类似铅笔或钢笔，那么这个值就是介于0-180之间的唯一值。 如果这个色块圆的，那么这个值就没有效用。如果这个色块完全不具有对称性，您只能由此得到0-360度的旋转。 您也可以通过索引 [7] 取得这个值。 blob.code() 返回一个16位的二进制数字，其中为每个颜色阈值设置一个位，这是色块的一部分。 例如，如果您通过 image.find_blobs 来寻找三个颜色阈值，这个色块可以设置为0/1/2位。 注意：除非以 merge=True 调用 image.find_blobs ，否则每个色块只能设置一位。 那么颜色阈值不同的多个色块就可以合并在一起了。 您也可以用这个方法以及多个阈值来实现颜色代码跟踪。 您也可以通过索引 [8] 取得这个值。 blob.count() 返回合并为这一色块的多个色块的数量。只有您以 merge=True 调用 image.find_blobs 时，这个数字才不是1。 您也可以通过索引 [9] 取得这个值。 blob.area() 返回色块周围的边框面积(w * h) blob.density() 返回这个色块的密度比。这是在色块边界框区域内的像素点的数量。 总的来说，较低的密度比意味着这个对象的锁定得不是很好。 Line类 – 直线对象 直线对象是由 image.find_lines , image.find_line_segments 或 image.get_regression 返回的。 构造函数 class image.line 请调用 image.find_lines(), image.find_line_segments(), 或 image.get_regression() 函数来创建此对象。 方法 line.line() 返回一个直线元组(x1, y1, x2, y2) ，用于如 image.draw_line 等其他的 image 方法。 line.x1() 返回直线的p1顶点 x坐标分量。 您也可以通过索引 [0] 取得这个值。 line.y1() 返回直线的p1 y分量。 您也可以通过索引 [1] 取得这个值。 line.x2() 返回直线的p2 x分量。 您也可以通过索引 [2] 取得这个值。 line.y2() 返回直线的p2 y分量。 您也可以通过索引 [3] 取得这个值。 line.length() 返回直线长度即 sqrt(((x2-x1)^2) + ((y2-y1)^2). 您也可以通过索引 [4] 取得这个值。 line.magnitude() 返回霍夫变换后的直线的长度。 您也可以通过索引 [5] 取得这个值。 line.theta() 返回霍夫变换后的直线的角度（0-179度）。 您也可以通过索引 [7] 取得这个值。 line.rho() 返回霍夫变换后的直线p值。 您也可以通过索引 [8] 取得这个值。 Circle类 –圆形对象 圆形对象是由 image.find_circles 返回的。 构造函数 class image.circle 请调用 image.find_circles() 函数来创建此对象。 方法 circle.x() 返回圆的x位置。 您也可以通过索引 [0] 取得这个值。 circle.y() 返回圆的y位置。 您也可以通过索引 [1] 取得这个值。 circle.r() 返回圆的半径。 您也可以通过索引 [2] 取得这个值。 circle.magnitude() 返回圆的大小。 您也可以通过索引 [3] 取得这个值。 Rect类 – 矩形对象 矩形对象是由 image.find_rects 返回的。 构造函数 class image.rect 请调用 image.find_rects() 函数来创建此对象。 方法 rect.corners() 返回一个由矩形对象的四个角组成的四个元组(x,y)的列表。四个角通常是按照从左上角开始沿顺时针顺序返回的。 rect.rect() 返回一个矩形元组(x, y, w, h)，用于如 矩形的边界框的 image.draw_rectangle 等其他的 image 方法。 rect.x() 返回矩形的左上角的x位置。 您也可以通过索引 [0] 取得这个值。 rect.y() 返回矩形的左上角的y位置。 您也可以通过索引 [1] 取得这个值。 rect.w() 返回矩形的宽度。 您也可以通过索引 [2] 取得这个值。 rect.h() 返回矩形的高度。 您也可以通过索引 [3] 取得这个值。 rect.magnitude() 返回矩形的大小。 您也可以通过索引 [4] 取得这个值。 QRCode类 – 二维码对象 二维码对象是由 image.find_qrcodes 返回的。 构造函数 class image.qrcode 请调用 image.find_qrcodes() 函数来创建此对象。 方法 qrcode.corners() 返回一个由该对象的四个角组成的四个元组(x,y)的列表。四个角通常是按照从左上角开始沿顺时针顺序返回的。 qrcode.rect() 返回一个矩形元组(x, y, w, h)，用于如二维码的边界框的 image.draw_rectangle 等其他的 image 方法。 qrcode.x() 返回二维码的边界框的x坐标(int)。 您也可以通过索引 [0] 取得这个值。 qrcode.y() 返回二维码的边界框的y坐标(int)。 您也可以通过索引 [1] 取得这个值。 qrcode.w() 返回二维码的边界框的w坐标(int)。 您也可以通过索引 [2] 取得这个值。 qrcode.h() 返回二维码的边界框的h坐标(int)。 您也可以通过索引 [3] 取得这个值。 qrcode.payload() 返回二维码有效载荷的字符串，例如URL 。 您也可以通过索引 [4] 取得这个值。 qrcode.version() 返回二维码的版本号(int)。 您也可以通过索引 [5] 取得这个值。 qrcode.ecc_level() 返回二维码的ECC水平(int)。 您也可以通过索引 [6] 取得这个值。 qrcode.mask() 返回二维码的掩码(int)。 您也可以通过索引 [7] 取得这个值。 qrcode.data_type() 返回二维码的数据类型。 您也可以通过索引 [8] 取得这个值。 qrcode.eci() 返回二维码的ECI。ECI储存了QR码中存储数据字节的编码。若您想要处理包含超过标准ASCII文本的二维码，您需要查看这一数值。 您也可以通过索引 [9] 取得这个值。 qrcode.is_numeric() 若二维码的数据类型为数字式，则返回True。 qrcode.is_alphanumeric() 若二维码的数据类型为文字数字式，则返回True。 qrcode.is_binary() 若二维码的数据类型为二进制式，则返回True。如果您认真处理所有类型的文本，则需要检查eci是否为True，以确定数据的文本编码。通常它只是标准的ASCII，但是它也可能是有两个字节字符的UTF8。 qrcode.is_kanji() 若二维码的数据类型为日本汉字，则返回True。设置为True后，您就需要自行解码字符串，因为日本汉字符号每个字符是10位，而MicroPython不支持解析这类文本。 AprilTag类 – AprilTag对象 AprilTag对象是由 image.find_apriltags 返回的。 构造函数 class image.apriltag 请调用 image.find_apriltags() 函数来创建此对象。 方法 apriltag.corners() 返回一个由该对象的四个角组成的四个元组(x,y)的列表。四个角通常是按照从左上角开始沿顺时针顺序返回的。 apriltag.rect() 返回一个矩形元组(x, y, w, h)，用于如AprilTag边界框的 image.draw_rectangle 等其他的 image 方法。 apriltag.x() 返回AprilTag边界框的x坐标(int)。 您也可以通过索引 [0] 取得这个值。 apriltag.y() 返回AprilTag边界框的y坐标(int)。 您也可以通过索引 [1] 取得这个值。 apriltag.w() 返回AprilTag边界框的w坐标(int)。 您也可以通过索引 [2] 取得这个值。 apriltag.h() 返回AprilTag边界框的h坐标(int)。 您也可以通过索引 [3] 取得这个值。 apriltag.id() 返回AprilTag的数字ID。 TAG16H5 -> 0 to 29 TAG25H7 -> 0 to 241 TAG25H9 -> 0 to 34 TAG36H10 -> 0 to 2319 TAG36H11 -> 0 to 586 ARTOOLKIT -> 0 to 511 您也可以通过索引 [4] 取得这个值。 apriltag.family() 返回AprilTag的数字家庭。 image.TAG16H5 image.TAG25H7 image.TAG25H9 image.TAG36H10 image.TAG36H11 image.ARTOOLKIT 您也可以通过索引 [5] 取得这个值。 apriltag.cx() 返回AprilTag的中心x位置(int)。 您也可以通过索引 [6] 取得这个值。 apriltag.cy() 返回AprilTag的中心y位置(int)。 您也可以通过索引 [7] 取得这个值。 apriltag.rotation() 返回以弧度计的AprilTag的旋度(int)。 您也可以通过索引 [8] 取得这个值。 apriltag.decision_margin() 返回AprilTag匹配的色饱和度（取值0.0 - 1.0），其中1.0为最佳。 您也可以通过索引 [9] 取得这个值。 apriltag.hamming() 返回AprilTag的可接受的数位误差数值。 TAG16H5 -> 最多可接受0位错误 TAG25H7 -> 最多可接受1位错误 TAG25H9 -> 最多可接受3位错误 TAG36H10 -> 最多可接受3位错误 TAG36H11 -> 最多可接受4位错误 ARTOOLKIT -> 最多可接受0位错误 您也可以通过索引 [10] 取得这个值。 apriltag.goodness() 返回AprilTag图像的色饱和度（取值0.0 - 1.0），其中1.0为最佳。 目前这一数值通常是0.0。未来我们可以启用一个称为“标签细化”的功能，以实现对更小的AprilTag的检测。然而，现在这个功能将帧速率降低到1 FPS以下。 您也可以通过索引 [11] 取得这个值。 apriltag.x_translation() 返回距离摄像机x方向的变换，距离的单位未知。 这个方法对于确定远离摄像机的AprilTag的位置很有用。但是，AprilTag的大小以及您使用的镜头等因素都会影响X单元归属的确定。为使用方便，我们推荐您使用查找表将该方法的输出转换为对您的应用程序有用的信息。 注意：此处的方向为从左至右。 您也可以通过索引 [12] 取得这个值。 apriltag.y_translation() 返回距离摄像机y方向的变换，距离的单位未知。 这个方法对于确定远离摄像机的AprilTag的位置很有用。但是，AprilTag的大小以及您使用的镜头等因素都会影响Y单元归属的确定。为使用方便，我们推荐您使用查找表将该方法的输出转换为对您的应用程序有用的信息。 注意：此处的方向为从上至下。 您也可以通过索引 [13] 取得这个值。 apriltag.z_translation() 返回距离摄像机z方向的变换，距离的单位未知。 T这个方法对于确定远离摄像机的AprilTag的位置很有用。但是，AprilTag的大小以及您使用的镜头等因素都会影响Z单元归属的确定。为使用方便，我们推荐您使用查找表将该方法的输出转换为对您的应用程序有用的信息。 注意：此处的方向为从前至后。 您也可以通过索引 [14] 取得这个值。 apriltag.x_rotation() 返回以弧度计的AprilTag在X平面上的旋度。例：目视AprilTag，从左至右移动摄像头。 您也可以通过索引 [15] 取得这个值。 apriltag.y_rotation() 返回以弧度计的AprilTag在Y平面上的旋度。例：目视AprilTag，从上至下移动摄像头。 您也可以通过索引 [16] 取得这个值。 apriltag.z_rotation() 返回以弧度计的AprilTag在Z平面上的旋度。例：目视AprilTag，旋转摄像头。 注意：这只是 apriltag.rotation() 的重命名版本。 您也可以通过索引 [17] 取得这个值。 DataMatrix类 – 数据矩阵对象 数据矩阵对象是由 image.find_datamatrices 返回的。 构造函数 class image.datamatrix 请调用 image.find_datamatrices() 函数来创建此对象。 方法 datamatrix.corners() 返回一个由该对象的四个角组成的四个元组(x,y)的列表。四个角通常是按照从左上角开始沿顺时针顺序返回的。 datamatrix.rect() 返回一个矩形元组(x, y, w, h)，用于如数据矩阵的边界框的 image.draw_rectangle 等其他的 image 方法。 datamatrix.x() 返回数据矩阵的边界框的x坐标(int)。 您也可以通过索引 [0] 取得这个值。 datamatrix.y() 返回数据矩阵的边界框的y坐标(int)。 您也可以通过索引 [1] 取得这个值。 datamatrix.w() 返回数据矩阵的边界框的w宽度。 您也可以通过索引 [2] 取得这个值。 datamatrix.h() 返回数据矩阵的边界框的h高度。 您也可以通过索引 [3] 取得这个值。 datamatrix.payload() 返回数据矩阵的有效载荷的字符串。例：字符串。 您也可以通过索引 [4] 取得这个值。 datamatrix.rotation() 返回以弧度计的数据矩阵的旋度(浮点数)。 您也可以通过索引 [5] 取得这个值。 datamatrix.rows() 返回数据矩阵的行数(int)。 您也可以通过索引 [6] 取得这个值。 datamatrix.columns() 返回数据矩阵的列数(int)。 您也可以通过索引 [7] 取得这个值。 datamatrix.capacity() 返回这一数据矩阵所能容纳的字符的数量。 您也可以通过索引 [8] 取得这个值。 datamatrix.padding() 返回这一数据矩阵中未使用的字符的数量。 您也可以通过索引 [9] 取得这个值。 BarCode类 – 条形码对象 条形码对象是由 image.find_barcodes 返回的。 构造函数 class image.barcode 请调用 image.find_barcodes() 函数来创建此对象。 方法 barcode.corners() 返回一个由该对象的四个角组成的四个元组(x,y)的列表。四个角通常是按照从左上角开始沿顺时针顺序返回的。 barcode.rect() 返回一个矩形元组(x, y, w, h)，用于如数据矩阵的边界框的 image.draw_rectangle 等其他的 image 方法。 barcode.x() 返回条形码的边界框的x坐标(int)。 您也可以通过索引 [0] 取得这个值。 barcode.y() 返回条形码的边界框的y坐标(int)。 您也可以通过索引 [1] 取得这个值。 barcode.w() 返回条形码的边界框的w宽度(int)。 您也可以通过索引 [2] 取得这个值。 barcode.h() 返回条形码的边界框的h高度(int)。 您也可以通过索引 [3] 取得这个值。 barcode.payload() 返回条形码的有效载荷的字符串。例：数量。 您也可以通过索引 [4] 取得这个值。 barcode.type() 返回条形码的列举类型 (int)。 您也可以通过索引 [5] 取得这个值。 image.EAN2 image.EAN5 image.EAN8 image.UPCE image.ISBN10 image.UPCA image.EAN13 image.ISBN13 image.I25 image.DATABAR image.DATABAR_EXP image.CODABAR image.CODE39 image.PDF417 - 未来启用 (e.g. 现在还不能正常使用). image.CODE93 image.CODE128 barcode.rotation() 返回以弧度计的条形码的旋度(浮点数)。 您也可以通过索引 [6] 取得这个值。 barcode.quality() 返回条形码在图像中被检测到的次数(int)。 扫描条形码时，每一条新的扫描线都能解码相同的条形码。每次进行这一过程，条形码的值都会随之增加。 您也可以通过索引 [7] 取得这个值。 Displacement类 – 位移对象 位移对象由 image.find_displacement 返回。 构造函数 class image.displacement 请调用 image.find_displacement() 函数来创建此对象。 方法 displacement.x_translation() 返回两个图像之间的x平移像素。 这是精确的子像素，所以它是一个浮点数。 您也可以通过索引 [0] 取得这个值。 displacement.y_translation() 返回两个图像之间的y平移像素。 这是精确的子像素，所以它是一个浮点数。 您也可以通过索引 [1] 取得这个值。 displacement.rotation() 返回两个图像之间的z平移像素。 这是精确的子像素，所以它是一个浮点数。 您也可以通过索引 [2] 取得这个值。 displacement.scale() 返回两个图像之间旋转的弧度。 您也可以通过索引 [3] 取得这个值。 displacement.response() 返回两幅图像之间位移匹配结果的质量。 范围 0-1。响应小于0.1的 displacement 对象可能是噪声。 您也可以通过索引 [4] 取得这个值。 Kptmatch类 – 特征点对象 特征点对象是由 image.match_descriptor 返回的。 构造函数 class image.kptmatch 请调用 image.match_descriptor() 函数来创建此对象。 方法 kptmatch.rect() 返回一个矩形元组(x, y, w, h)，用于如特征点的边界框的 image.draw_rectangle 等其他的 image 方法。 kptmatch.cx() 返回特征点的中心x位置(int)。 您也可以通过索引 [0] 取得这个值。 kptmatch.cy() 返回特征点的中心y位置(int)。 您也可以通过索引 [1] 取得这个值。 kptmatch.x() 返回特征点边界框的x坐标(int)。 您也可以通过索引 [2] 取得这个值。 kptmatch.y() 返回特征点边界框的y坐标(int)。 您也可以通过索引 [3] 取得这个值。 kptmatch.w() 返回特征点边界框的w宽度(int)。 您也可以通过索引 [4] 取得这个值。 kptmatch.h() 返回特征点边界框的h高度(int)。 您也可以通过索引 [5] 取得这个值。 kptmatch.count() 返回匹配的特征点的数量(int)。 您也可以通过索引 [6] 取得这个值。 kptmatch.theta() 返回估计的特征点的旋度(int)。 您也可以通过索引 [7] 取得这个值。 kptmatch.match() 返回匹配关键点的(x，y)元组列表。 您也可以通过索引 [8] 取得这个值。 ImageWriter类 – ImageWriter对象 ImageWriter 对象使得您可以快速地将未压缩的图像写入磁盘。 ＃　构造函数 class image.ImageWriter(path) 创建一个ImageWriter对象，您就可以以用于OpenMV Cams的简单文件格式将未压缩的图像写到磁盘上。然后未压缩的图像可以使用ImageReader重新读取。 方法 imagewriter.size() 返回正在写入的文件的大小。 imagewriter.add_frame(img) 将一张图像写入磁盘。由于图像未被压缩，因此执行迅速，但会占用大量磁盘空间。 imagewriter.close() 关闭图像流文件。您必须关闭文件，否则文件会损坏。 ImageReader 类– ImageReader对象 ImageReader对象使得您可以快速地从磁盘中读取未压缩的图像。 构造函数 class image.ImageReader(path) 创建一个ImageReader对象，用来回放由ImageWriter对象编写的图像数据。ImageWriter对象回放的帧会在与写入磁盘时相同的FPS下回放。 方法 imagereader.size() 返回正在读取的文件的大小。 imagereader.next_frame([copy_to_fb=True, loop=True]) 从ImageWriter写就的文件中返回图像对象。若 copy_to_fb 为True，图像对象将被直接加载到帧缓冲区中。否则图像对象将被放入堆中。注意：除非图像很小，否则堆可能没有足够的空间来存储图像对象。 若 loop 为True，流的最后一个图像读取之后，回放将重新开始。否则所有帧被读取后，这个方法将返回None。 注意： imagereader.next_frame 尝试在读取帧后通过暂停播放来限制回放速度，以与帧记录的速度相匹配。 否则，这个方法会以200+FPS的速度图像快读播放所有图像。 imagereader.close() 关闭正在读取的文件。您需要进行这一操作，以防imagereader 对象受损。但由于是只读文件，文件不会在未关闭时受损。 Image类 – 图像对象 图像对象是机器视觉操作的基本对象。 构造函数 class image.Image(path[, copy_to_fb=False]) 从 path 中的文件中创建一个新的图像对象。 支持bmp/pgm/ppm/jpg/jpeg格式的图像文件。 若 copy_to_fb 为True，图像会直接载入帧缓冲区，您就可以加载大幅图片了。若为False，图像会载入MicroPython的堆中，堆远比帧缓冲区小。 在OpenMV Cam M4中，若 copy_to_fb 为False，您应该尽量把图像大小控制在8KB以下。若为True，则图像最大可为160KB。 在OpenMV Cam M7中，若 copy_to_fb 为False，您应该尽量把图像大小控制在16KB以下。若为True，则图像最大可为320KB。 图像支持“[]”记法。 令 image[index] = 8/16-bit value ，以便分配图像像素或 image[index] ，并得到一个图像像素，若是用于RGB图像的16位RGB565值的灰度图像， 这一像素则为8位。 对于JPEG图像而言，“[]”使得您可以访问压缩的节数组形式的JPEG图像色块。由于JPEG图像是压缩的字节流形式，因而对数据组的读取和写入是不透明的。 图像还支持读缓冲区操作。您可以把图像当作节数组对象，将图像输入所有类型的MicroPython函数。若您想传送一个图像，可以将它传递给UART /SPI/ I2C写入函数，可实现自动传送。 方法 image.width() 返回以像素计的图像的宽度。 image.height() 返回以像素计的图像的高度。 image.format() 返回用于灰度图的 sensor.GRAYSCALE 、用于RGB图像的 sensor.RGB565 和用于JPEG图像的 sensor.JPEG 。 image.size() 返回以字节计的图像大小。 image.get_pixel(x, y[, rgbtuple]) 灰度图：返回(x, y)位置的灰度像素值。 RGB565l：返回(x, y)位置的RGB888像素元组(r, g, b)。 Bayer图像: 返回(x, y)位置的像素值。 不支持压缩图像。 image.get_pixel() 和 image.set_pixel()是允许你操作Bayer模式图像的唯一方法。 Bayer模式图像是文字图像。对于偶数行，其中图像中的像素是R/G/R/G/等。 对于奇数行，其中图像中的像素是G/B/G/B/等。 每个像素是8位。 image.set_pixel(x, y, pixel) 灰度图：将(x, y) 位置的像素设置为灰度值 pixel 。 RGB图像：将(x, y) 位置的像素设置为RGB888元组(r, g, b) pixel 。 不支持压缩图像。 image.get_pixel() 和 image.set_pixel()是允许你操作Bayer模式图像的唯一方法。 Bayer模式图像是文字图像。对于偶数行，其中图像中的像素是R/G/R/G/等。 对于奇数行，其中图像中的像素是G/B/G/B/等。 每个像素是8位。 image.mean_pool(x_div, y_div) 在图像中找到 x_div * y_div 正方形的平均值，并返回由每个正方形的平均值组成的修改图像。 此方法允许您在原来图像上快速缩小图像。 不支持压缩图像和bayer图像。 image.mean_pooled(x_div, y_div) 在图像中找到 x_div * y_div 正方形的平均值，并返回由每个正方形的平均值组成的新图像。 此方法允许您创建缩小的图像副本。 不支持压缩图像和bayer图像。 image.midpoint_pool(x_div, y_div[, bias=0.5]) 在图像中找到 x_div * y_div 正方形的中点值，并返回由每个正方形的中点值组成的修改图像。 bias 为0.0返回每个区域的最小值，而bias 为1.0返回每个区域的最大值。 此方法允许您在原来图像上快速缩小图像。 不支持压缩图像和bayer图像。 image.midpoint_pooled(x_div, y_div[, bias=0.5]) 在图像中找到 x_div * y_div 正方形的中点值，并返回由每个正方形的中点值组成的新图像。 bias 为0.0返回每个区域的最小值，而bias 为1.0返回每个区域的最大值。 此方法允许您创建缩小的图像副本。 不支持压缩图像和bayer图像。 image.to_grayscale([copy=False]) 将图像转换为灰度图像。 此方法也会修改基础图像像素，以字节为单位更改图像大小，因此只能在灰度图像或RGB565图像上进行。 否则 copy 必须为True才能在堆上创建新的修改图像。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.to_rgb565([copy=False]) 将图像转换为彩色图像。 此方法也会修改基础图像像素，以字节为单位更改图像大小，因此只能在RGB565图像上进行。 否则 copy 必须为True才能在堆上创建新的修改图像。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.to_rainbow([copy=False]) 将图像转换为彩虹图像。 此方法也会修改基础图像像素，以字节为单位更改图像大小，因此只能在RGB565图像上进行。 否则 copy 必须为True才能在堆上创建新的修改图像。 彩虹图像是彩色图像，对于图像中的每个8位掩模灰度照明值具有唯一的颜色值。 例如，它为热图像提供热图颜色。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.compress([quality=50]) JPEG对图像进行适当压缩。使用这种方法与 compressed 保存堆空间相比，使用更高quality的压缩率是以破坏原始图像为代价的。 quality 是压缩质量（0-100）（int）。 image.compress_for_ide([quality=50]) JPEG对图像进行适当压缩。使用这种方法与 compressed 保存堆空间相比，使用更高quality的压缩率是以破坏原始图像为代价的。 这个方法压缩图像，然后通过将每6比特编码为128 - 191之间的字节将JPEG数据格式化，转换为OpenMV IDE，以便显示。进行这一步是为防止JPEG数据被误认为是字节流中的其他文本数据。 您需要使用这一方法来格式化图像数据，以便在OpenMV IDE中通过“开放终端”创建的终端窗口中显示。 quality 是压缩质量（0-100）（int）。 image.compressed([quality=50]) 返回一个JPEG压缩图像—原始图像未经处理。但是，这个方法需要堆空间的大分配，所以图像压缩质量和图像分辨率必须很低。 quality 是压缩质量（0-100）（int）。 image.compressed_for_ide([quality=50]) 返回一个JPEG压缩图像—原始图像未经处理。但是，这个方法需要堆空间的大分配，所以图像压缩质量和图像分辨率必须很低。 这个方法压缩图像，然后通过将每6比特编码为128 - 191之间的字节将JPEG数据格式化，转换为OpenMV IDE，以便显示。进行这一步是为防止JPEG数据被误认为是字节流中的其他文本数据。 您需要使用这一方法来格式化图像数据，以便在OpenMV IDE中通过“开放终端”创建的终端窗口中显示。 quality 是压缩质量（0-100）（int）。 image.copy([roi[, copy_to_fb=False]]) 创建一个图像对象的副本。 Roi 是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定，ROI即复制整个图像的图像矩形。但这不适用于JPEG图像。 请记住图像副本储存在MicroPython 堆中而不是帧缓冲区。同样，您需要将图像副本大小控制在8KB以下（OpenMV）或16KB以下（OpenMV Cam M7） 如果您想使用一个复制操作来使用所有的堆空间，这个函数会出现异常。过大的图像极易触发异常。 如果 copy_to_fb 为True，则该方法将帧缓冲替换为图像。 帧缓冲区具有比堆大得多的空间，并且可以容纳大图像。 image.save(path[, roi[, quality=50]]) 将图像的副本保存到 path 中的文件系统。 支持bmp/pgm/ppm/jpg/jpeg格式的图像文件。注意：您无法将jpeg格式的压缩图像保存成未压缩的格式。 roi 是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定，ROI即复制整个图像的图像矩形。但这不适用于JPEG图像。 quality 指在图像尚未被压缩时将图像保存为JPEG格式的JPEG压缩质量。 image.clear() 将图像中的所有像素设置为零（非常快）。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像。 image.draw_line(x0, y0, x1, y1[, color[, thickness=1]]) 在图像上绘制一条从(x0，y0)到(x1，y1)的线。 您可以单独传递x0，y0，x1，y1，也可以传递给元组(x0，y0，x1，y1)。 color 是用于灰度或RGB565图像的RGB888元组。默认为白色。但是，您也可以传递灰度图像的基础像素值(0-255)或RGB565图像的字节反转RGB565值。 thickness 控制线的粗细像素。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.draw_rectangle(x, y, w, h[, color[, thickness=1[, fill=False]]]) 在图像上绘制一个矩形。 您可以单独传递x，y，w，h或作为元组(x，y，w，h)传递。 color 是用于灰度或RGB565图像的RGB888元组。默认为白色。但是，您也可以传递灰度图像的基础像素值(0-255)或RGB565图像的字节反转RGB565值。 thickness 控制线的粗细像素。 将 fill 设置为True以填充矩形。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.draw_circle(x, y, radius[, color[, thickness=1[, fill=False]]]) 在图像上绘制一个圆形。 您可以单独传递x，y，半径 或 作为元组(x，y，radius)传递。 color 是用于灰度或RGB565图像的RGB888元组。默认为白色。但是，您也可以传递灰度图像的基础像素值(0-255)或RGB565图像的字节反转RGB565值。 thickness 控制线的粗细像素。 将 fill 设置为True以填充圆形。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.draw_string(x, y, text[, color[, scale=1[, x_spacing=0[, y_spacing=0[, mono_space=True]]]]]) 从图像中的(x, y)位置开始绘制8x10文本。您可以单独传递x，y，也可以作为元组(x，y)传递。 text 是写入图像的字符串。 \\n, \\r, 和 \\r\\n 结束符将光标移至下一行。 color 是用于灰度或RGB565图像的RGB888元组。默认为白色。但是，您也可以传递灰度图像的基础像素值(0-255)或RGB565图像的字节反转RGB565值。 可以增加 scale 以增加图像上文本的大小。 仅整数值（例如，1/2/3 /等）。 x_spacing 允许你在字符之间添加（如果是正数）或减去（如果是负数）x像素，设置字符间距。 y_spacing 允许你在字符之间添加（如果是正数）或减去（如果是负数）y像素，设置行间距。 mono_space 默认为True，强制文本间距固定。对于大文本，这看起来很糟糕。设置False以获得非固定宽度的字符间距，看起来好多了。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.draw_cross(x, y[, color[, size=5[, thickness=1]]]) 在图像上绘制一个十字。 您可以单独传递x，y或作为元组(x，y)传递。 color 是用于灰度或RGB565图像的RGB888元组。默认为白色。但是，您也可以传递灰度图像的基础像素值(0-255)或RGB565图像的字节反转RGB565值。 size 控制十字线的延伸长度。 thickness 控制边缘的像素厚度。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.draw_arrow(x0, y0, x1, y1[, color[, thickness=1]]) 在图像上绘制一条从(x0，y0)到(x1，y1)的箭头。 您可以单独传递x0，y0，x1，y1，也可以传递给元组(x0，y0，x1，y1)。 color 是用于灰度或RGB565图像的RGB888元组。默认为白色。但是，您也可以传递灰度图像的基础像素值(0-255)或RGB565图像的字节反转RGB565值。 thickness 控制线的粗细像素。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.draw_image(image, x, y[, x_scale=1.0[, y_scale=1.0[, mask=None]]]) 绘制一个 image ，其左上角从位置x，y开始。 您可以单独传递x，y，也可以传递给元组(x，y)。 x_scale 控制图像在x方向(浮点数)缩放的程度。 y_scale 控制图像在y方向(浮点数)缩放的程度。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 您可以使用mask掩码进行绘制操作。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.draw_keypoints(keypoints[, color[, size=10[, thickness=1[, fill=False]]]]) 在图像上画出一个特征点对象的各个点。 color 是用于灰度或RGB565图像的RGB888元组。默认为白色。但是，您也可以传递灰度图像的基础像素值(0-255)或RGB565图像的字节反转RGB565值。 size 控制特征点的大小。 thickness 控制线的粗细像素。 将 fill 设置为True以填充特征点。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.flood_fill(x, y[, seed_threshold=0.05[, floating_threshold=0.05[, color[, invert=False[, clear_background=False[, mask=None]]]]]]) 从位置x，y开始填充图像的区域。 您可以单独传递x，y，也可以传递给元组(x，y)。 seed_threshold 控制填充区域中的像素与原始起始像素的差异。 floating_threshold 控制填充区域中的像素与任何相邻像素的差异。 color 是用于灰度或RGB565图像的RGB888元组。默认为白色。但是，您也可以传递灰度图像的基础像素值(0-255)或RGB565图像的字节反转RGB565值。 将 invert 传递为True，以重新填充flood_fill连接区域外的所有内容。 将 clear_background 传递为True，将其余的flood_fill没有重新着色的像素归零。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩膜中设置的像素会在flood_fill时被评估。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.binary(thresholds[, invert=False[, zero=False[, mask=None]]]) 根据像素是否在阈值列表 thresholds 中的阈值内，将图像中的所有像素设置为黑色或白色。 thresholds 必须是元组列表。 [(lo, hi), (lo, hi), ..., (lo, hi)] 定义你想追踪的颜色范围。 对于灰度图像，每个元组需要包含两个值 - 最小灰度值和最大灰度值。 仅考虑落在这些阈值之间的像素区域。 对于RGB565图像，每个元组需要有六个值(l_lo，l_hi，a_lo，a_hi，b_lo，b_hi) - 分别是LAB L，A和B通道的最小值和最大值。 为方便使用，此功能将自动修复交换的最小值和最大值。 此外，如果元组大于六个值，则忽略其余值。相反，如果元组太短，则假定其余阈值处于最大范围。 注解 获取所跟踪对象的阈值，只需在IDE帧缓冲区中选择（单击并拖动）跟踪对象。 直方图会相应地更新到所在区域。然后只需写下颜色分布在每个直方图通道中起始与下降位置。 这些将是 thresholds 的低值和高值。 由于上下四分位数据相差微小，故手动确定阈值为佳。 您还可以通过进入OpenMV IDE中的 工具 ->机器视觉 ->阈值编辑器 并从GUI窗口中拖动滑块来确定颜色阈值。 invert 反转阈值操作，像素在已知颜色范围之外进行匹配，而非在已知颜色范围内。 设置 zero 为True来使阈值像素为零，并使不在阈值列表中的像素保持不变。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.invert() 将二进制图像0（黑色）变为1（白色），1（白色）变为0（黑色），非常快速地翻转二进制图像中的所有像素值。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和Bayer图像。 image.b_and(image[, mask=None]) 用另一图像与这一图像进行逻辑与运算。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.b_nand(image[, mask=None]) 用另一图像与这一图像进行逻辑与非运算。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.b_or(image[, mask=None]) 用另一图像与这一图像进行逻辑或运算。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.b_nor(image[, mask=None]) 用另一图像与这一图像进行逻辑或非运算。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.b_xor(image[, mask=None]) 用另一图像与这一图像进行逻辑异或运算。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.b_xnor(image[, mask=None]) 用另一图像与这一图像进行逻辑同或运算。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.erode(size[, threshold[, mask=None]]) 从分割区域的边缘删除像素。 这一方法通过卷积图像上((size2)+1)x((size2)+1)像素的核来实现，如果相邻像素集的总和小于 threshold ，则对内核的中心像素进行归零。 若 threshold 未设定，这个方法的功能如标准腐蚀方法一样。若threshold设定，您就可以指定腐蚀的特定像素，例如：设置低于2个的像素周围阈值为2。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.dilate(size[, threshold[, mask=None]]) 将像素添加到分割区域的边缘中。 这一方法通过卷积图像上((size2)+1)x((size2)+1)像素的核来实现，如果相邻像素集的总和大于 threshold ，则将内核的中心像素进行设置。 若 threshold 未设定，这个方法的功能如标准腐蚀方法一样。若threshold设定，您就可以指定腐蚀的特定像素，例如：设置低于2个的像素周围阈值为2。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.open(size[, threshold[, mask=None]]) 按顺序对图像执行腐蚀和膨胀。有关更多信息，请参阅 image.erode() 和 image.dilate() 。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.close(size[, threshold[, mask=None]]) 按顺序对图像执行膨胀和腐蚀。有关更多信息，请参阅 image.erode() 和 image.dilate() 。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.top_hat(size[, threshold[, mask=None]]) 返回原图像和执行 image.open() 函数后图像的差异。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 不支持压缩图像和bayer图像。 image.black_hat(size[, threshold[, mask=None]]) 返回原图像和执行 image.close() 函数后图像的差异。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 不支持压缩图像和bayer图像。 image.negate() 非常快速地翻转（数字反转）图像中的所有像素值。对每个颜色通道的像素值进行数值转换。例： (255 - pixel). 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.replace(image[, hmirror=False[, vflip=False[, mask=None]]]) image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 将 hmirror 设置为True以水平镜像替换图像。 将 vflip 设置为True以垂直翻转替换图像。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.add(image[, mask=None]) 将两个图像彼此按像素相加。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.sub(image[, reverse=False[, mask=None]]) 将两个图像彼此按像素相减。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 将 reverse 设置为True可以将减法操作从 this_image-image 反转为 image-this_image 。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.mul(image[, invert=False[, mask=None]]) 将两个图像彼此按像素相乘。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 将 invert 设置为True可将乘法运算从 ab 改为 1/((1/a)(1/b))。 特别是，这使图像变亮而不是使图像变暗(例如，乘法与刻录操作)。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.div(image[, invert=False[, mask=None]]) 将此图像除以另一个图像。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 将 invert 设置为True可将除法方向从 a/b 改为 b/a。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.min(image[, mask=None]) 在像素级 用此图像和另一个图像之间的最小像素值替换此图像中的像素。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 这个方法在OpenMV4上不可用. image.max(image[, mask=None]) 在像素级 用此图像和另一个图像之间的最大像素值替换此图像中的像素。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.difference(image[, mask=None]) 将两个图像彼此按像素取绝对值。例：对于每个颜色通道而言，将每个像素替换为ABS(this.pixel-image.pixel)。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.blend(image[, alpha=128[, mask=None]]) 将另外一张图像 image 与这一图像融合。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 alpha 控制要混合到这个图像中的其他图像的多少. alpha 应该是0到256之间的整数值。接近零的值会将更多其他图像混合到此图像中，接近256则相反。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.histeq([adaptive=False[, clip_limit=-1[, mask=None]]]) 在图像上运行直方图均衡算法。 直方图均衡化使图像中的对比度和亮度标准化。 如果 adaptive 传递为True，那么将在图像上运行自适应直方图均衡方法，这通常比非自适应直方图限定更好，但运行时间更长。 clip_limit 提供了一种限制自适应直方图均衡的对比度的方法。 使用较小的值(例如10)可以生成良好的直方图均衡对比度受限图像。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.mean(size, [threshold=False, [offset=0, [invert=False, [mask=None]]]]]) 使用盒式滤波器的标准均值模糊滤波。 Size 是内核的大小。取1 (3x3 内核)、2 (5x5 内核)或更高值。 如果你想在滤波器的输出上自适应地设置阈值，你可以传递 threshold=True 参数来启动图像的自适应阈值处理， 他根据环境像素的亮度（核函数周围的像素的亮度有关），将像素设置为1或者0。 负数 offset 值将更多像素设置为1，而正值仅将最强对比度设置为1。 设置 invert 以反转二进制图像的结果输出。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 median(size, percentile=0.5, threshold=False, offset=0, invert=False, mask]) 在图像上运行中值滤波。在保留边缘的条件下，中值滤波是用来平滑表面的最佳滤波，但是运行速度极慢。 Size 是内核的大小。取1 (3x3 内核)、2 (5x5 内核)或更高值。 percentile 控制内核中所使用值的百分位数。默认情况下，每个像素都使用相邻的第五十个百分位数（中心）替换。使用最小滤波时，您可将此值设置为0，使用下四分位数滤波时设置为0.25，使用上四分位数滤波时设置为0.75，使用最大滤波时设置为1。 如果你想在滤波器的输出上自适应地设置阈值，你可以传递 threshold=True 参数来启动图像的自适应阈值处理， 他根据环境像素的亮度（核函数周围的像素的亮度有关），将像素设置为1或者0。 负数 offset 值将更多像素设置为1，而正值仅将最强对比度设置为1。 设置 invert 以反转二进制图像的结果输出。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.mode(size[, threshold=False, offset=0, invert=False, mask]) 在图像上运行众数滤波，用相邻像素的模式替换每个像素。这一方法在灰度图上运行效果良好。但由于这一操作的非线性特性，会在RGB图像边缘上产生许多伪像。 Size 是内核的大小。取1 (3x3 内核)、2 (5x5 内核)。 如果你想在滤波器的输出上自适应地设置阈值，你可以传递 threshold=True 参数来启动图像的自适应阈值处理， 他根据环境像素的亮度（核函数周围的像素的亮度有关），将像素设置为1或者0。 负数 offset 值将更多像素设置为1，而正值仅将最强对比度设置为1。 设置 invert 以反转二进制图像的结果输出。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.midpoint(size[, bias=0.5, threshold=False, offset=0, invert=False, mask]) 在图像上运行中点滤波。此滤波器找到图像中每个像素邻域的中点((max-min)/2)。 size 是内核的大小。取1 (3x3 内核)、2 (5x5 内核)或更高值。 bias 控制图像混合的最小/最大程度。0只适用于最小滤波，1仅用于最大滤波。您可以通过 bias 对图像进行最小/最大化过滤。 如果你想在滤波器的输出上自适应地设置阈值，你可以传递 threshold=True 参数来启动图像的自适应阈值处理， 他根据环境像素的亮度（核函数周围的像素的亮度有关），将像素设置为1或者0。 负数 offset 值将更多像素设置为1，而正值仅将最强对比度设置为1。 设置 invert 以反转二进制图像的结果输出。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.morph(size, kernel, mul=Auto, add=0) 通过过滤器内核对图像进行卷积。这允许您对图像执行通用卷积。 size 将内核的大小控制为((size2)+1)x((size2)+1)像素。 kernel 用来卷积图像的内核，可为一个元组或一个取值[-128:127]的列表。 mul 是用以与卷积像素结果相乘的数字。若不设置，则默认一个值，该值将防止卷积输出中的缩放。 add 是用来与每个像素卷积结果相加的数值。 mul 可进行全局对比度调整，add可进行全局亮度调整。 如果你想在滤波器的输出上自适应地设置阈值，你可以传递 threshold=True 参数来启动图像的自适应阈值处理， 他根据环境像素的亮度（核函数周围的像素的亮度有关），将像素设置为1或者0。 负数 offset 值将更多像素设置为1，而正值仅将最强对比度设置为1。 设置 invert 以反转二进制图像的结果输出。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.gaussian(size[, unsharp=False[, mul[, add=0[, threshold=False[, offset=0[, invert=False[, mask=None]]]]]]]) 通过平滑高斯核对图像进行卷积。 size 是内核的大小。取1 (3x3 内核)、2 (5x5 内核)或更高值。 如果 unsharp 设置为True，那么这种方法不会仅进行高斯滤波操作，而是执行非锐化掩模操作，从而提高边缘的图像清晰度。 mul 是用以与卷积像素结果相乘的数字。若不设置，则默认一个值，该值将防止卷积输出中的缩放。 add 是用来与每个像素卷积结果相加的数值。 mul 可进行全局对比度调整，add可进行全局亮度调整。 如果你想在滤波器的输出上自适应地设置阈值，你可以传递 threshold=True 参数来启动图像的自适应阈值处理， 他根据环境像素的亮度（核函数周围的像素的亮度有关），将像素设置为1或者0。 负数 offset 值将更多像素设置为1，而正值仅将最强对比度设置为1。 设置 invert 以反转二进制图像的结果输出。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.laplacian(size[, sharpen=False[, mul[, add=0[, threshold=False[, offset=0[, invert=False[, mask=None]]]]]]]) 通过边缘检测拉普拉斯核来对图像进行卷积。 size 是内核的大小。取1 (3x3 内核)、2 (5x5 内核)或更高值。 如果 sharpen 被设置为True，那么这种方法将改为锐化图像，而不是仅输出未经过阈值处理的边缘检测图像。 增加内核大小然后增加图像清晰度。 mul 是用以与卷积像素结果相乘的数字。若不设置，则默认一个值，该值将防止卷积输出中的缩放。 add 是用来与每个像素卷积结果相加的数值。 mul 可进行全局对比度调整，add可进行全局亮度调整。 如果你想在滤波器的输出上自适应地设置阈值，你可以传递 threshold=True 参数来启动图像的自适应阈值处理， 他根据环境像素的亮度（核函数周围的像素的亮度有关），将像素设置为1或者0。 负数 offset 值将更多像素设置为1，而正值仅将最强对比度设置为1。 设置 invert 以反转二进制图像的结果输出。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.bilateral(size[, color_sigma=0.1[, space_sigma=1[, threshold=False[, offset=0[, invert=False[, mask=None]]]]]]) 通过双边滤波器对图像进行卷积。 双边滤波器使图像平滑，同时保持图像中的边缘。 size 是内核的大小。取1 (3x3 内核)、2 (5x5 内核)或更高值。 color_sigma 控制使用双边滤波器匹配颜色的接近程度。增加此值可增加颜色模糊。 space_sigma 控制像素在空间方面相互模糊的程度。增加此值可增加像素模糊。 如果你想在滤波器的输出上自适应地设置阈值，你可以传递 threshold=True 参数来启动图像的自适应阈值处理， 他根据环境像素的亮度（核函数周围的像素的亮度有关），将像素设置为1或者0。 负数 offset 值将更多像素设置为1，而正值仅将最强对比度设置为1。 设置 invert 以反转二进制图像的结果输出。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.cartoon(size[, seed_threshold=0.05[, floating_threshold=0.05[, mask=None]]]) 漫游图像并使用flood-fills算法填充图像中的所有像素区域。 这通过使图像的所有区域中的颜色变平来有效地从图像中去除纹理。 为了获得最佳效果，图像应具有大量对比度，以使区域不会太容易相互渗透。 seed_threshold 控制填充区域中的像素与原始起始像素的差异。 floating_threshold 控制填充区域中的像素与任何相邻像素的差异。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.remove_shadows([image]) 从该图像中移除阴影。 如果当前图像没有“无阴影”版本出现，则此方法将尝试从图像中去除阴影，但没有真实无阴影的图像依据。 这种算法适用于去除平坦均匀背景中的阴影。 请注意，此方法需要多秒才能运行，并且仅适用于实时移除阴影，动态生成无阴影版本的图像。 该算法的未来版本将适用于更多的环境，但同样缓慢。 如果当前图像有“无阴影”版本出现，则此方法将使用“真实源”背景无阴影图像去除图像中的所有阴影以滤除阴影。 非阴影像素不会被过滤掉，因此您可以向场景中添加以前不存在的新对象，并且这些对象中的任何非阴影像素都将显示出来。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 只支持RGB565图像。 此方法在OpenMV Cam M4 上不可用。 image.chrominvar() 从图像中删除照明效果，仅留下颜色渐变。比 image.illuminvar() 更快但受阴影影响。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 仅支持RGB565图像。 此方法在OpenMV Cam M4 上不可用。 image.illuminvar() 从图像中删除照明效果，仅留下颜色渐变。比 image.chrominvar() 慢但不受阴影影响。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 仅支持RGB565图像。 此方法在OpenMV Cam M4 上不可用。 image.linpolar([reverse=False]) 图像从笛卡尔坐标到线性极坐标重新投影。 设置 reverse = True 可以在相反的方向重新投影。 线性极坐标重新投影将图像旋转转换为x平移。 不支持压缩图像。 此方法在OpenMV Cam M4 上不可用。 image.logpolar([reverse=False]) 图像从笛卡尔坐标到对数极坐标重新投影。 设置 reverse = True 可以在相反的方向重新投影。 对数极坐标重新投影将图像的旋转转换为x平移和缩放到y平移。 不支持压缩图像。 此方法在OpenMV Cam M4 上不可用。 image.lens_corr([strength=1.8[, zoom=1.0]]) 进行镜头畸变校正，以去除镜头造成的图像鱼眼效果。 strength 是一个浮点数，该值确定了对图像进行去鱼眼效果的程度。在默认情况下，首先试用取值1.8，然后调整这一数值使图像显示最佳效果。 zoom 是在对图像进行缩放的数值。默认值为 1.0 。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 img.rotation_corr([x_rotation=0.0[, y_rotation=0.0[, z_rotation=0.0[, x_translation=0.0[, y_translation=0.0[, zoom=1.0]]]]]]) 通过执行帧缓冲区的3D旋转来纠正图像中的透视问题。 x_rotation 是围绕x轴在帧缓冲器中旋转图像的度数（这使图像上下旋转）。 y_rotation 是帧缓冲区中围绕y轴旋转图像的度数（即左右旋转图像）。 z_rotation 是围绕z轴在帧缓冲器中旋转图像的度数（即，使图像旋转到适当位置）。 x_translation 是旋转后将图像移动到左侧或右侧的单位数。因为这个变换是应用在三维空间的，单位不是像素… y_translation 是旋转后将图像上移或下移的单位数。因为这个变换是应用在三维空间的，单位不是像素… zoom 是通过图像缩放的量。默认情况下1.0。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.get_similarity(image) 返回一个“相似度”对象，描述两幅图像使用SSIM算法来比较两幅图像之间的8x8像素色块的相似度。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.get_histogram([thresholds[, invert=False[, roi[, bins[, l_bins[, a_bins[, b_bins]]]]]]]) 在 roi 的所有颜色通道上进行标准化直方图运算，并返回 histogram 对象。 请参考 histogram 对象以获取更多信息。您也可以使用 image.get_hist 或 image.histogram 来调用这一方法。如果传递 thresholds 列表，则直方图信息将仅从阈值列表中的像素计算得出。 thresholds 必须是元组列表。 [(lo, hi), (lo, hi), ..., (lo, hi)] 定义你想追踪的颜色范围。 对于灰度图像，每个元组需要包含两个值 - 最小灰度值和最大灰度值。 仅考虑落在这些阈值之间的像素区域。 对于RGB565图像，每个元组需要有六个值(l_lo，l_hi，a_lo，a_hi，b_lo，b_hi) - 分别是LAB L，A和B通道的最小值和最大值。 为方便使用，此功能将自动修复交换的最小值和最大值。 此外，如果元组大于六个值，则忽略其余值。相反，如果元组太短，则假定其余阈值处于最大范围。 注解 获取所跟踪对象的阈值，只需在IDE帧缓冲区中选择（单击并拖动）跟踪对象。 直方图会相应地更新到所在区域。然后只需写下颜色分布在每个直方图通道中起始与下降位置。 这些将是 thresholds 的低值和高值。 由于上下四分位数据相差微小，故手动确定阈值为佳。 您还可以通过进入OpenMV IDE中的 工具 ->机器视觉 ->阈值编辑器 并从GUI窗口中拖动滑块来确定颜色阈值。 invert 反转阈值操作，像素在已知颜色范围之外进行匹配，而非在已知颜色范围内。 除非您需要使用颜色统计信息进行高级操作，否则只需使用image.get_statistics() 方法代替此方法查看图像中的像素区域。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 bins 和其他bin是用于直方图通道的箱数。对于灰度图像，使用 bins ， 对于RGB565图像，使用其他每个通道。每个通道的bin计数必须大于2。 另外，将bin计数设置为大于每个通道的唯一像素值的数量是没有意义的。 默认情况下，直方图将具有每个通道的最大bin数。 不支持压缩图像和bayer图像。 image.get_statistics([thresholds[, invert=False[, roi[, bins[, l_bins[, a_bins[, b_bins]]]]]]]) 计算 roi 中每个颜色通道的平均值、中值、众值、标准偏差、最小值、最大值、下四分值和上四分值，并返回一个数据对象。 请参见 statistics 对象以获取更多信息。您也可以使用 image.get_stats 或 image.statistics 来调用这一方法。 如果传递 thresholds 列表，则直方图信息将仅从阈值列表中的像素计算得出。 thresholds 必须是元组列表。 [(lo, hi), (lo, hi), ..., (lo, hi)] 定义你想追踪的颜色范围。 对于灰度图像，每个元组需要包含两个值 - 最小灰度值和最大灰度值。 仅考虑落在这些阈值之间的像素区域。 对于RGB565图像，每个元组需要有六个值(l_lo，l_hi，a_lo，a_hi，b_lo，b_hi) - 分别是LAB L，A和B通道的最小值和最大值。 为方便使用，此功能将自动修复交换的最小值和最大值。 此外，如果元组大于六个值，则忽略其余值。相反，如果元组太短，则假定其余阈值处于最大范围。 注解 获取所跟踪对象的阈值，只需在IDE帧缓冲区中选择（单击并拖动）跟踪对象。 直方图会相应地更新到所在区域。然后只需写下颜色分布在每个直方图通道中起始与下降位置。 这些将是 thresholds 的低值和高值。 由于上下四分位数据相差微小，故手动确定阈值为佳。 您还可以通过进入OpenMV IDE中的 工具 ->机器视觉 ->阈值编辑器 并从GUI窗口中拖动滑块来确定颜色阈值。 invert 反转阈值操作，像素在已知颜色范围之外进行匹配，而非在已知颜色范围内。 您可以在需要获取图像中一个像素区域信息时使用这一方法。例如：若您想用帧差法来检测运动时， 您需要使用这一方法来确定图像颜色通道的变化，从而触发运动检测阈值。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 bins 和其他bin是用于直方图通道的箱数。对于灰度图像，使用 bins ， 对于RGB565图像，使用其他每个通道。每个通道的bin计数必须大于2。 另外，将bin计数设置为大于每个通道的唯一像素值的数量是没有意义的。 默认情况下，直方图将具有每个通道的最大bin数。 不支持压缩图像和bayer图像。 image.get_regression(thresholds[, invert=False[, roi[, x_stride=2[, y_stride=1[, area_threshold=10[, pixels_threshold=10[, robust=False]]]]]]]) 对图像所有阈值像素进行线性回归计算。这一计算通过最小二乘法进行，通常速度较快，但不能处理任何异常值。 若 robust 为True，则将使用泰尔指数。泰尔指数计算图像中所有阈值像素间的所有斜率的中值。 若在阈值转换后设定太多像素，即使在80x60的图像上，这一N^2操作也可能将您的FPS降到5以下。 但是，只要阈值转换后的进行设置的像素数量较少，即使在超过30%的阈值像素为异常值的情况下，线性回归也依然有效。 这一方法返回的是一个 image.line 对象。如何轻松运用直线对象， 详见下博文： https://openmv.io/blogs/news/linear-regression-line-following thresholds 必须是元组列表。 [(lo, hi), (lo, hi), ..., (lo, hi)] 定义你想追踪的颜色范围。 对于灰度图像，每个元组需要包含两个值 - 最小灰度值和最大灰度值。 仅考虑落在这些阈值之间的像素区域。 对于RGB565图像，每个元组需要有六个值(l_lo，l_hi，a_lo，a_hi，b_lo，b_hi) - 分别是LAB L，A和B通道的最小值和最大值。 为方便使用，此功能将自动修复交换的最小值和最大值。 此外，如果元组大于六个值，则忽略其余值。相反，如果元组太短，则假定其余阈值处于最大范围。 获取所跟踪对象的阈值，只需在IDE帧缓冲区中选择（单击并拖动）跟踪对象。 直方图会相应地更新到所在区域。然后只需写下颜色分布在每个直方图通道中起始与下降位置。 这些将是 thresholds 的低值和高值。 由于上下四分位数据相差微小，故手动确定阈值为佳。 您还可以通过进入OpenMV IDE中的 工具 ->机器视觉 ->阈值编辑器 并从GUI窗口中拖动滑块来确定颜色阈值。 invert 反转阈值操作，像素在已知颜色范围之外进行匹配，而非在已知颜色范围内。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 x_stride 是调用函数时要跳过的x像素数。 y_stride 是调用函数时要跳过的y像素数。 如果回归后的边界框区域小于 area_threshold ，则返回None。 如果回归后的像素数小于 pixel_threshold ，则返回None。 不支持压缩图像和bayer图像。 image.find_blobs(thresholds[, invert=False[, roi[, x_stride=2[, y_stride=1[, area_threshold=10[, pixels_threshold=10[, merge=False[, margin=0[, threshold_cb=None[, merge_cb=None]]]]]]]]]]) 查找图像中所有色块，并返回一个包括每个色块的色块对象的列表。请观察 image.blob 对象以获取更多信息。 thresholds 必须是元组列表。 [(lo, hi), (lo, hi), ..., (lo, hi)] 定义你想追踪的颜色范围。 对于灰度图像，每个元组需要包含两个值 - 最小灰度值和最大灰度值。 仅考虑落在这些阈值之间的像素区域。 对于RGB565图像，每个元组需要有六个值(l_lo，l_hi，a_lo，a_hi，b_lo，b_hi) - 分别是LAB L，A和B通道的最小值和最大值。 为方便使用，此功能将自动修复交换的最小值和最大值。 此外，如果元组大于六个值，则忽略其余值。相反，如果元组太短，则假定其余阈值处于最大范围。 注解 获取所跟踪对象的阈值，只需在IDE帧缓冲区中选择（单击并拖动）跟踪对象。 直方图会相应地更新到所在区域。然后只需写下颜色分布在每个直方图通道中起始与下降位置。 这些将是 thresholds 的低值和高值。 由于上下四分位数据相差微小，故手动确定阈值为佳。 您还可以通过进入OpenMV IDE中的 工具 ->机器视觉 ->阈值编辑器 并从GUI窗口中拖动滑块来确定颜色阈值。 invert 反转阈值操作，像素在已知颜色范围之外进行匹配，而非在已知颜色范围内。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 x_stride 是查找某色块时需要跳过的x像素的数量。找到色块后，直线填充算法将精确像素。 若已知色块较大，可增加 x_stride 来提高查找色块的速度。 y_stride 是查找某色块时需要跳过的y像素的数量。找到色块后，直线填充算法将精确像素。 若已知色块较大，可增加 y_stride 来提高查找色块的速度。 若一个色块的边界框区域小于 area_threshold ，则会被过滤掉。 若一个色块的像素数小于 pixel_threshold ，则会被过滤掉。 merge 若为True，则合并所有没有被过滤掉的色块，这些色块的边界矩形互相交错重叠。 margin 可在相交测试中用来增大或减小色块边界矩形的大小。例如：边缘为1、相互间边界矩形为1的色块将被合并。 合并色块使颜色代码追踪得以实现。每个色块对象有一个代码值 code ，该值为一个位向量。 例如：若您在 image.find_blobs 中输入两个颜色阈值，则第一个阈值代码为1，第二个代码为2（第三个代码为4，第四个代码为8，以此类推）。 合并色块对所有的code使用逻辑或运算，以便您知道产生它们的颜色。这使得您可以追踪两个颜色，若您用两种颜色得到一个色块对象，则可能是一种颜色代码。 若您使用严格的颜色范围，无法完全追踪目标对象的所有像素，您可能需要合并色块。 最后，若您想要合并色块，但不想两种不同阈值颜色的色块被合并，只需分别两次调用 image.find_blobs ，不同阈值色块就不会被合并。 threshold_cb 可设置为用以调用阈值筛选后的每个色块的函数，以便将其从将要合并的色块列表中过滤出来。 回调函数将收到一个参数：要被筛选的色块对象。然后回调函数需返回True以保留色块或返回False以过滤色块。 merge_cb 可设置为用以调用两个即将合并的色块的函数，以禁止或准许合并。回调函数将收到两个参数—两个将被合并的色块对象。 回调函数须返回True以合并色块，或返回False以防止色块合并。 不支持压缩图像和bayer图像。 image.find_lines([roi[, x_stride=2[, y_stride=1[, threshold=1000[, theta_margin=25[, rho_margin=25]]]]]]) 使用霍夫变换查找图像中的所有直线。返回一个 image.line 对象的列表。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。操作范围仅限于 roi 区域内的像素。 x_stride 是霍夫变换时需要跳过的x像素的数量。若已知直线较大，可增加 x_stride 。 y_stride 是霍夫变换时需要跳过的y像素的数量。若已知直线较大，可增加 y_stride 。 threshold 控制从霍夫变换中监测到的直线。只返回大于或等于 threshold 的直线。 应用程序的正确的 threshold 值取决于图像。注意：一条直线的大小(magnitude)是组成直线所有索贝尔滤波像素大小的总和。 theta_margin 控制所监测的直线的合并。 直线角度为 theta_margin 的部分和直线p值为 rho_margin 的部分合并。 rho_margin 控制所监测的直线的合并。 直线角度为 theta_margin 的部分和直线p值为 rho_margin 的部分合并。 该方法通过在图像上运行索贝尔滤波器，并利用该滤波器的幅值和梯度响应来进行霍夫变换。 无需对图像进行任何预处理。但是，清理图像过滤器可得到更为稳定的结果。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.find_line_segments([roi[, merge_distance=0[, max_theta_difference=15]]]) 使用霍夫转换来查找图像中的线段。返回一个 image.line 对象的列表。 roi 是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定， ROI 即图像矩形。操作范围仅限于roi区域内的像素。 merge_distance 指定两条线段之间的可以相互分开而不被合并的最大像素数。 max_theta_difference 是上面 merge_distancede 要合并的的两个线段的最大角度差值。 此方法使用LSD库（也被OpenCV使用）来查找图像中的线段。这有点慢，但是非常准确，线段不会跳跃。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.find_circles([roi[, x_stride=2[, y_stride=1[, threshold=2000[, x_margin=10[, y_margin=10[, r_margin=10]]]]]]]) 使用霍夫变换在图像中查找圆。返回一个 image.circle 对象列表（见上）。 roi 是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定， ROI 即图像矩形。操作范围仅限于roi区域内的像素。 x_stride 是霍夫变换时需要跳过的x像素的数量。若已知圆较大，可增加 x_stride 。 y_stride 是霍夫变换时需要跳过的y像素的数量。若已知圆较大，可增加 y_stride 。 threshold 控制从霍夫变换中监测到的圆。只返回大于或等于 threshold 的圆。 应用程序的正确的 threshold 值取决于图像。注意：一个圆的大小(magnitude)是组成圆所有索贝尔滤波像素大小的总和。 x_margin 控制所检测的圆的合并。 圆像素为 x_margin 、 y_margin 和 r_margin 的部分合并。 y_margin 控制所检测的圆的合并。 圆像素为 x_margin 、 y_margin 和 r_margin 的部分合并。 r_margin 控制所检测的圆的合并。 圆像素为 x_margin 、 y_margin 和 r_margin 的部分合并。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.find_rects([roi=Auto, threshold=10000]) 使用用于查找AprilTAg的相同的quad detection算法来查找图像中的矩形。 最适用与背景形成鲜明对比的矩形。AprilTag的quad detection可以处理任意缩放/旋转/剪切的矩形。 返回一个 image.rect 对象的列表。 roi 是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定， ROI即图像矩形。操作范围仅限于 roi 区域内的像素。 边界大小（通过在矩形边缘上的所有像素上滑动索贝尔算子并相加该值）小于 threshold 的矩形会从返回列表中过滤出来。 threshold 的正确值取决于您的应用程序/场景。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.find_qrcodes([roi]) 查找 roi 内的所有二维码并返回一个 image.qrcode 对象的列表。 请参考 image.qrcode 对象以获取更多信息。 为使这一方法成功运行，图像上二维码需比较平展。通过使用 sensor.set_windowing 函数在镜头中心放大、 image.lens_corr 函数来消解镜头的桶形畸变或通过更换视野较为狭小的镜头， 您可得到一个不受镜头畸变影响的更为平展的二维码。有些机器视觉镜头不会造成桶形失真，但是其造价远比OpenMV提供的标准镜片高，这种镜头为无畸变镜头。 roi 是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定，ROI即整幅图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.find_apriltags([roi[, families=image.TAG36H11[, fx[, fy[, cx[, cy]]]]]]) 查找 roi 内的所有AprilTag, 并返回一个 image.apriltag 对象的列表。请参考 image.apriltag 对象以获取更多信息。 与二维码相比，AprilTags可在更远距离、较差光线和更扭曲的图像环境下被检测到。 AprilTags可应对所有种类的图像失真问题，而二维码并不能。也就是说，AprilTags只能将数字ID编码作为其有效载荷。 AprilTags也可用于本地化。每个 image.apriltag 对象都从摄像机返回其三维位置信息和旋转角度。 位置信息由 fx 、 fy 、 cx 和 cy 决定，分别为X和Y方向上图像的焦距和中心点。 使用OpenMV IDE内置的标签生成器工具来创建AprilTags。标签生成器可创建可打印的8.5“x11”AprilTags。 roi 是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定，ROI即整幅图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 families 是要解码的标签家族的位掩码。是一个逻辑或： image.TAG16H5 image.TAG25H7 image.TAG25H9 image.TAG36H10 image.TAG36H11 image.ARTOOLKIT 默认设置为最好用的 image.TAG36H11 标签家族。注意：每启用一个标签家族， find_apriltags 的速度都会略有放慢。 fx 是以像素为单位的相机x方向的焦距。标准OpenMV Cam的值为(2.8 / 3.984) * 656， 该值通过毫米计的焦距值除以X方向上感光元件的长度，再乘以X方向上感光元件的像素数量得来（对OV7725感光元件而言）。 fy 是以像素为单位的相机y方向的焦距。标准OpenMV Cam的值为(2.8 / 2.952) * 488， 该值通过毫米计的焦距值除以Y方向上感光元件的长度，再乘以Y方向上感光元件的像素数量得来（对OV7725感光元件而言）。 cx 是图像的中心，即 image.width()/2 ，而非 roi.w()/2 。 cy 是图像的中心，即 image.height()/2，而非 roi.h()/2 。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.find_datamatrices([roi[, effort=200]]) 查找 roi 内的所有数据矩阵并返回一个 image.datamatrix 对象的列表。 请参考 image.datamatrix 对象以获取更多信息。 为使这一方法成功运行，图像上矩形码需比较平展。通过使用 sensor.set_windowing 函数在镜头中心放大、 image.lens_corr 函数来消解镜头的桶形畸变或通过更换视野较为狭小的镜头，您可得到一个不受镜头畸变影响的更为平展的矩形码。 有些机器视觉镜头不会造成桶形失真，但是其造价远比OpenMV提供的标准镜片高，这种镜头是无畸变镜头。 roi 是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定，ROI即整幅图像的图像矩形。操作范围仅限于 roi 区域内的像素。 effort 控制用于查找矩形码匹配的时间。默认值为200应该适用于所有用例。 但是您也可能以帧速率为代价增加检测，或以检测为代价增加帧速率。 注意：若 effort 设置在约160以下，您就无法进行任何检测；相反，您可将其设置为您需要的任何高值，但是若设置值高于240，检测率将不会继续随之提高。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.find_barcodes([roi]) 查找 roi 内所有一维条形码并返回一个 image.barcode 对象列表。 请参考 image.barcode 对象以获取更多信息。 为了获得最佳效果，请使用长640、宽40/80／160窗口。垂直程度越低，运行速度越快。由于条形码是线性一维图像，所以只需在一个方向上有较高分辨率， 而在另一方向上只需较低分辨率。注意：该函数进行水平和垂直扫描，所以您可使用宽40/80／160、长480的窗口。 最后，请一定调整镜头，这样条形码会定位在焦距产生最清晰图像的地方。模糊条码无法被解码。 该函数支持所有一维条形码： image.EAN2 image.EAN5 image.EAN8 image.UPCE image.ISBN10 image.UPCA image.EAN13 image.ISBN13 image.I25 image.DATABAR (RSS-14) image.DATABAR_EXP (RSS-Expanded) image.CODABAR image.CODE39 image.PDF417 image.CODE93 image.CODE128 roi 是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定，ROI即整幅图像的图像矩形。操作范围仅限于 roi 区域内的像素。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.find_displacement(template[, roi[, template_roi[, logpolar=False]]]) 从模板中查找此图像的变换偏移量。 这种方法可以用来做光流。 此方法返回一个 image.displacement 对象，其中包含使用相位相关的位移计算结果。 roi 是需要处理的矩形区域（x，y，w，h）。如果未指定，则等于图像矩形。 template_roi 是需要处理的矩形区域（x，y，w，h）。如果未指定，则等于图像矩形。 roi 和 template roi必须具有相同的w/h，但x/y可以为图像任意位置。您可以在较大图像上滑动较小的rois以获得光流渐变图像. image.find_displacement 通常计算两个图像之间的x/y平移。但是，如果您设置 logpolar = True ， 它将会在两个图像之间找到旋转和缩放比例的变化。相同的 image.displacement 对象结果两种可能的反馈。 不支持压缩图像和bayer图像。 注解 请在长宽一致的图像（例如sensor.B64X64）上使用此方法。 此方法在OpenMV Cam M4 上不可用。 image.find_number(roi) 运行在MINST数据集上训练的LENET-6 CNN（卷积神经网络），以检测位于图像上任何位置的28x28 ROI中的数字。 返回一个包含整数和浮点数的元组，表示检测到的数字（0-9）和检测的置信度（0-1）。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 仅支持灰度图像。 注解 这种方法是实验性的。如果未来运行使用Caffe在PC上训练的任何CNN，这种方法可能会删除。 最新3.0.0版本固件已删除此函数。 此方法在OpenMV Cam M4 上不可用。 image.classify_object(roi) 在图像的ROI上运行CIFAR-10 CNN，以检测飞机，汽车，鸟类，猫，鹿，狗，青蛙，马，船和卡车。 此方法在内部自动将图像缩放到32x32以馈送到CNN。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 仅支持RGB565图像。 注解 这种方法是实验性的。如果未来运行使用Caffe在PC上训练的任何CNN，这种方法可能会删除。 此方法在OpenMV Cam M4 上不可用。 image.find_template(template, threshold[, roi[, step=2[, search=image.SEARCH_EX]]]) 尝试使用归一化互相关(NCC)算法在图像中找到第一个模板匹配的位置。返回匹配位置的边界框元组(x, y, w, h)，否则返回None。 template 是一个与这个图像对象相匹配的小图像对象。注意：两图像须都为灰度图。 threshold 是浮点数（0.0-1.0），其中较小的值在提高检测速率同时增加误报率。相反，较高的值会降低检测速率，同时降低误报率。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 step 是查找模板时需要跳过的像素数量。跳过像素可大大提高算法运行的速度。该方法只适用于SERACH_EX模式下的算法。 search 可为 image.SEARCH_DS or image.SEARCH_EX. image.SEARCH_DS 搜索模板所用算法较 image.SEARCH_EX 更快，但若模板位于图像边缘周围，可能无法成功搜索。 image.SEARCH_EX 可对图像进行较为详尽的搜索，但其运行速度远低于 image.SEARCH_DS 。 仅支持灰度图像。 image.find_features(cascade[, threshold=0.5[, scale=1.5[, roi]]]) 这个方法搜索与Haar Cascade匹配的所有区域的图像，并返回一个关于这些特征的边界框矩形元组(x，y，w，h)的列表。若未发现任何特征，则返回一个空白列表。 cascade 是一个Haar Cascade对象。详细信息请查看 image.HaarCascade() 。 threshold 是浮点数（0.0-1.0），其中较小的值在提高检测速率同时增加误报率。相反，较高的值会降低检测速率，同时降低误报率。 scale 是一个必须大于1.0的浮点数。较高的比例因子运行更快，但其图像匹配相应较差。理想值介于1.35-1.5之间。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 仅支持灰度图像。 image.find_eye(roi) 在眼睛周围的感兴趣区域(x, y, w, h)查找瞳孔。返回一个包含图像中瞳孔(x，y)位置的元组。若未发现瞳孔，则返回(0,0)。 使用这一函数之前，需首先使用 image.find_features() 和Haar算子 frontalface 来搜索某人面部。 然后使用 image.find_features 和Haar算子 find_eye 在面部搜索眼睛。 最后，在调用 image.find_features 函数后返回的每个眼睛ROI上调用这一方法，以得到瞳孔的坐标。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 仅支持灰度图像。 image.find_lbp(roi) 从ROI元组(x, y, w, h)中提取LBP（局部二值模式）键点。您可以使用 image.match_descriptor 函数来比较两组关键点，以获取匹配距离。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 仅支持灰度图像。 image.find_keypoints([roi[, threshold=20[, normalized=False[, scale_factor=1.5[, max_keypoints=100[, corner_detector=image.CORNER_AGAST]]]]]]) 从ROI元组(x, y, w, h)中提取ORB键点。您可以使用 image.match_descriptor 函数来比较两组关键点，以获取匹配区域。若未发现关键点，则返回None。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 threshold 是控制提取的数量的数字（取值0-255）。对于默认的AGAST角点检测器，该值应在20左右。 对于FAST角点检测器，该值约为60-80。阈值越低，您提取的角点越多。 normalized 是布尔值。若为True，在多分辨率下关闭提取键点。 若您不关心处理扩展问题，且希望算法运行更快，就将之设置为True。 scale_factor 是一个必须大于1.0的浮点数。较高的比例因子运行更快，但其图像匹配相应较差。理想值介于1.35-1.5之间。 max_keypoints 是一个键点对象所能容纳的键点最大数量。若键点对象过大导致内存问题，请降低该值。 corner_detector 是从图像中提取键点所使用的角点检测器算法。 可为 image.CORNER_FAST 或 image.CORNER_AGAST 。FAST角点检测器运行速度更快，但其准确度较低。 仅支持灰度图像。 image.find_edges(edge_type[, threshold]) 将图像变为黑白，仅将边缘保留为白色像素。 image.EDGE_SIMPLE - 简单的阈值高通滤波算法 image.EDGE_CANNY - Canny边缘检测算法 threshold 是一个包含一个低阈值和一个高阈值的二值元组。您可以通过调整该值来控制边缘质量。 默认为 (100, 200)。 仅支持灰度图像。 find_hog([roi[, size=8]]) 用HOG（定向梯度直方图）线替换ROI中的像素。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 仅支持灰度图像。 此方法在OpenMV Cam M4 上不可用。 常量 image.SEARCH_EX 详尽的模板匹配搜索。 image.SEARCH_DS 更快的模板匹配搜索。 image.EDGE_CANNY 使用Canny边缘检测算法对图像进行边缘检测。 image.EDGE_SIMPLE 使用阈值高通滤波算法对图像进行边缘检测。 image.CORNER_FAST 用于ORB键点的高速低准确率角点检测算法 image.CORNER_AGAST 用于ORB键点的低速高准确率算法。 image.TAG16H5 TAG1H5标签群的位掩码枚举。用于AprilTags。 image.TAG25H7 TAG25H7标签群的位掩码枚举。用于AprilTags。 image.TAG25H9 TAG25H9标签群的位掩码枚举。用于AprilTags。 image.TAG36H10 TAG36H10标签群的位掩码枚举。用于AprilTags。 image.TAG36H11 TAG36H11标签群的位掩码枚举。用于AprilTags。 image.ARTOOLKIT ARTOOLKIT标签群的位掩码枚举。用于AprilTags。 image.EAN2 EAN2条形码类型枚举。 image.EAN5 EAN5条形码类型枚举。 image.EAN8 EAN8条形码类型枚举。 image.UPCE UPCE条形码类型枚举。 image.ISBN10 ISBN10条形码类型枚举。 image.UPCA UPCA条形码类型枚举。 image.EAN13 EAN13条形码类型枚举。 image.ISBN13 ISBN13条形码类型枚举。 image.I25 I25条形码类型枚举。 image.DATABAR DATABAR条形码类型枚举。 image.DATABAR_EXP DATABAR_EXP条形码类型枚举。 image.CODABAR CODABAR条形码类型枚举。 image.CODE39 CODE39条形码类型枚举。 image.PDF417 PDF417条形码类型枚举（目前尚不能运行）。 image.CODE93 CODE93条形码类型枚举。 image.CODE128 CODE128条形码类型枚举。 "},"libs/machine_vision/cpufreq.html":{"url":"libs/machine_vision/cpufreq.html","title":"CPUfreq","keywords":"","body":"Cpufreq Cpu frequency module, support program to modify cpu and kpu frequency method Get the current frequency Get the current cpu and kpu frequency, this method has 2 return values import cpufreq cpu_freq,kpu_freq = cpufreq.get_current_frequencies() Parameters no return value cpu_freq: the current cpu frequency, the unit is M kpu_freq: the current kpu frequency, the unit is M Get the frequency of kpu support Since kpu is the rate obtained by dividing by pll1 and the current pll1 frequency is fixed at 400M, it is currently unable to support any frequency. Cpu theoretically supports arbitrary frequencies, but it will be biased according to the actual hardware. import cpufreq kpu_freqlist = cpufreq.get_kpu_supported_frequencies() Parameters no return value kpu_freqlist: kpu support frequency list Setting frequency Set the cpu or kpu frequency, please note that some peripherals may change performance after the frequency setting is completed. import cpufreq kpu_freqlist = cpufreq.set_frequency(cpu = cpu_freq, kpu = kpu_freq) Parameters Parameters can be entered in 1 or 2 of cpu or kpu cpu_freq: cpu frequency to be set, range [26,400] kpu_freq: The kpu frequency you want to set, please see the `kpu support frequency list. return value After using this interface, if the frequency does not change, it returns null. If the frequency changes, the machine will be restarted. Please confirm whether the current situation can be restarted before using this interface. "},"libs/machine_vision/video.html":{"url":"libs/machine_vision/video.html","title":"video","keywords":"","body":"video 视频 支持播放和录制 avi 视频 全局函数 open(path, record=False, interval=100000, quality=50, width=320, height=240, audio=False, sample_rate=44100, channels=1) 打开一个文件来播放或者录制 参数 path： 文件路径， 比如 /sd/badapple.avi record： 是否进行录制， 如果选择 Ture， 则会进行录制视频，否则是播放视频。 默认 False interval： 录制的帧间隔， 单位是微秒， fps = 1000000/interval， 默认 100000， 即每秒10帧 quality： jpeg 压缩质量（%）， 默认50 width： 录制屏幕宽度， 默认 320 height： 录制屏幕高度， 默认 240 audio： 是否录制音频， 默认 False sample_rate： 录制音频采样率， 默认 44100 (44.1k) channels： 录制音频声道数， 默认 1， 即单声道 返回值 返回一个对象， 根据不同格式返回的对象不同。 目前只支持 avi 格式， 返回 由 avi 类创建的对象 类 avi 由 video.open() 函数返回 play() 播放视频， 每调用一次解析一次数据（音频或者视频） 返回值 0： 播放结束 1： 正在播放 2： 暂停（保留） 3： 当前解码的帧是视频帧 4： 当前解码的帧是音频帧 volume(volume) 设置音量 参数 volume： 音量值， 取值范围：[0,100] 返回值 设置的音量值， 取值范围 [0,100] record() 录制视频和音频， 每调用一次录制一帧，函数内部会限制速度，如果没有到录制设置的间隔，在到达设定的间隔之前会阻塞 返回值 录制的视频的当前帧的长度 例程 例程 1： 播放 avi 视频 首先保证视频是 320x240 大小， 视频压缩格式为 mjpeg， 音频压缩格式位 PCM。 可以在这里下载测试可以用的视频： badapple.avi import video,time from Maix import GPIO fm.register(34, fm.fpioa.I2S0_OUT_D1) fm.register(35, fm.fpioa.I2S0_SCLK) fm.register(33, fm.fpioa.I2S0_WS) fm.register(8, fm.fpioa.GPIO0) wifi_en=GPIO(GPIO.GPIO0,GPIO.OUT) wifi_en.value(0) v = video.open(\"/sd/badapple.avi\") print(v) v.volume(50) while True: if v.play() == 0: print(\"play end\") break v.__del__() 默认使用了 I2S0 来播放音频， 所以需要设置 I2S0 对应的引脚， 关闭WiFi是因为Dock板WiFi对音质的干扰 例程2： 录制 avi 视频 import video, sensor, image, lcd, time lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) sensor.skip_frames(30) v = video.open(\"/sd/capture.avi\", record=1, interval=200000, quality=50) i = 0 tim = time.ticks_ms() while True: tim = time.ticks_ms() img = sensor.snapshot() lcd.display(img) img_len = v.record(img) # print(\"record\",time.ticks_ms() - tim) i += 1 if i > 100: break print(\"finish\") v.record_finish() lcd.clear() 可以取消打印屏蔽来看实际的录制间隔有没有达到设置的帧间隔（比如这里设置的200000us） 实际打印应该是 200ms， 如果实际帧间隔大于设置的值，则说明实际性能没有达到设置的要求，需要调大设置的帧间隔即减小帧率。 另外去掉显示和打印也可以一定程度上增加帧率。 "},"libs/peripheral_modules/":{"url":"libs/peripheral_modules/","title":"外设模块","keywords":"","body":"外设模块 这里的外设模块主要指片外外设（相对于片上外设，比如GPIO、I2C等），比如 LCD、 摄像头、 触摸屏等等 关于图像相关的暂时放在了 机器视觉 分类， 包括以下外设模块 lcd： 显示图像 sensor： 获取摄像头数据， 取名叫 sensor 是兼容 openmv， 当然也不完全一样，请阅读文档 其它外设模块包括： touchscreen： 触摸屏相关操作，读取触摸屏点击状态以及获取点击的坐标等 "},"libs/peripheral_modules/touchscreen.html":{"url":"libs/peripheral_modules/touchscreen.html","title":"touchscreen","keywords":"","body":"touchscreen 触摸屏幕 touchscreen 模块包含了基本的读取触摸屏幕操作 目前支持的触摸屏幕： ns2009（默认） 如果需要修改驱动型号，需要重新编译 MaixPy 源码修改预编译支持的型号 全局函数 init(i2c=None, cal=None) 初始化触摸屏 API 在后面可能会有所改动（主要是针对多种驱动对参数的改动） 参数 i2c： 目前支持的是 I2C 通信的触摸屏， 传入I2C实例对象， 后期这个参数可能会被重命名或者取消 cal： 校准数据， 是一个 7 个整型值的元组， 可以通过 touchscreen.calibrate() 函数得到 calibrate() 校准屏幕，使屏幕显示和触摸屏像素能够对应 返回值 返回一个 7 个整型值的元组， 可以保存到文件系统或者flash，在初始化的时候传入，这样就不用每次都校准了 read() 读取当前屏幕的状态以及按下的点的坐标值 返回值 一个由 3 个整型值组成的元组 (status, x, y)， 注意这个值会一直保持上一个状态 status： 状态， 取值有 touchscreen.STATUS_PRESS， touchscreen.STATUS_MOVE， touchscreen.STATUS_RELEASE x： x 轴坐标 y： y 轴坐标 常量 touchscreen.STATUS_PRESS 屏幕被按下， read() 函数返回的元组的第一个值 touchscreen.STATUS_MOVE 屏幕被按住并移动，即按住移动， read() 函数返回的元组的第一个值 touchscreen.STATUS_RELEASE 屏幕不再被按住，即没有点击， read() 函数返回的元组的第一个值 例程 例程 1 ： 图画板 黑底白画笔画图板， 使用boot 按键可以清除内容 取消 ts.calibrate() 的注释可以在开始运行触摸屏校准程序 import touchscreen as ts from machine import I2C import lcd, image from board import board_info from fpioa_manager import * board_info=board_info() fm.register(board_info.BOOT_KEY, fm.fpioa.GPIO1) btn_clear = GPIO(GPIO.GPIO1, GPIO.IN) lcd.init() i2c = I2C(I2C.I2C0, freq=400000, scl=30, sda=31) ts.init(i2c) #ts.calibrate() lcd.clear() img = image.Image() status_last = ts.STATUS_IDLE x_last = 0 y_last = 0 draw = False while True: (status,x,y) = ts.read() print(status, x, y) if draw: img.draw_line((x_last, y_last, x, y)) if status_last!=status: if (status==ts.STATUS_PRESS or status == ts.STATUS_MOVE): draw = True else: draw = False status_last = status lcd.display(img) x_last = x y_last = y if btn_clear.value() == 0: img.clear() ts.__del__() "},"application/":{"url":"application/","title":"内置应用","keywords":"","body":"内置应用 pye: 集成在 MaixPy 中文件编辑器，直接通过串口编辑板子里的文件 nes: NES FC 红白机 模拟器 lvgl: LittlvGL 图形库 "},"application/pye.html":{"url":"application/pye.html","title":"Micropython Editor","keywords":"","body":"pye Micropython Editor 集成在 MaixPy 固件中文件编辑器， 可以直接通过串口终端修改板子里面的文件 使用方法： from pye_mp import pye pye(\"/sd/boot.py\") "},"application/nes.html":{"url":"application/nes.html","title":"nes","keywords":"","body":"NES 游戏模拟器 经典的 FC 红白机 游戏模拟器， 带我们回到小时候吧～～ 或者？ 让我们想办法让它自己玩自己？ 函数 init(rc_type=nes.KEYBOARD, cs, mosi, miso, clk, repeat=16, vol=5) 初始化 NES 模拟器 参数 tc_type： 遥控器类型， 键盘（nes.KEYBOARD）（注意是串口与电脑通信，而不是直接接USB键盘到开发板）或者手柄（nes.JOYSTICK）。 建议使用PS2手柄，体验会更好， 键盘通过串口工具输入可能不能同时按多个按键，当然也可以通过自己在PC写一个脚本来转发键值就能解决（去这里找找？） cs： 如果使用 SPI 接口的 PS2 手柄， 传入 cs 外设编号（注意不是引脚号，需要先映射引脚） mosi： 如果使用 SPI 接口的 PS2 手柄， 传入 mosi 外设编号（注意不是引脚号，需要先映射引脚） miso： 如果使用 SPI 接口的 PS2 手柄， 传入 miso 外设编号（注意不是引脚号，需要先映射引脚） clk： 如果使用 SPI 接口的 PS2 手柄， 传入 clk 外设编号（注意不是引脚号，需要先映射引脚） repeat： 这个参数只对使用键盘（/串口）时， 指按键的重复率 vol： 初始化时的音量， 后面可以通过按键调整 run(nes) 运行 NES 游戏 ROM 参数 nes： 游戏 ROM 路径， 比如 /sd/mario.nes 快捷键 键盘（/串口） 移动 ： W A S D A ： J B ： K start ： M 或者 Enter option： N 或者 \\ 退出 ： ESC 音量 - ： - 音量 + ： = 运行速度 - ： R 运行速度 + ： F 手柄 移动 ： 方向键 ^ V -> A ： □ B ： × start ： START select： SELECT 退出 ： 暂无 音量 - ： R2 音量 + ： R1 运行速度 - ： L1 运行速度 + ： L2 例 例 1： 键盘（串口） import nes, lcd lcd.init(freq=15000000) nes.init(nes.KEYBOARD) nes.run(\"/sd/mario.nes\") 例 2： PS2 手柄 import nes, lcd from fpioa_manager import fm fm.register(19, fm.fpioa.GPIOHS19) fm.register(18, fm.fpioa.GPIOHS18) fm.register(23, fm.fpioa.GPIOHS23) fm.register(21, fm.fpioa.GPIOHS21) lcd.init(freq=15000000) nes.init(nes.JOYSTICK, cs=fm.fpioa.GPIOHS19, clk=fm.fpioa.GPIOHS18, mosi=fm.fpioa.GPIOHS23, miso=fm.fpioa.GPIOHS21) nes.run(\"/sd/mario.nes\") "},"application/lvgl.html":{"url":"application/lvgl.html","title":"lvgl","keywords":"","body":"lvgl LittlevGL 参考官方文档： lvgl blog page 例程 例程 1： 按键 显示一个按键，并且可以通过触摸屏点击 import lvgl as lv import lvgl_helper as lv_h import lcd import time from machine import Timer from machine import I2C import touchscreen as ts i2c = I2C(I2C.I2C0, freq=400000, scl=30, sda=31) ts.init(i2c) lcd.init() lv.init() disp_drv = lv.disp_drv_t() lv.disp_drv_init(disp_drv) disp_drv.disp_flush = lv_h.flush disp_drv.disp_fill = lv_h.fill lv.disp_drv_register(disp_drv) indev_drv = lv.indev_drv_t() lv.indev_drv_init(indev_drv) indev_drv.type = lv.INDEV_TYPE.POINTER indev_drv.read = lv_h.read lv.indev_drv_register(indev_drv) scr = lv.obj() btn = lv.btn(scr) btn.align(lv.scr_act(), lv.ALIGN.CENTER, 0, 0) label = lv.label(btn) label.set_text(\"Button\") lv.scr_load(scr) while True: tim = time.ticks_ms() lv.tick_inc(5) lv.task_handler() while time.ticks_ms()-tim "},"advanced/compile.html":{"url":"advanced/compile.html","title":"代码编译","keywords":"","body":"源码编译 编译方法请参考 源码 ports/k210-freertos 目录下的 README "},"advanced/code_struct.html":{"url":"advanced/code_struct.html","title":"代码结构","keywords":"","body":"代码结构 本文主要介绍 Micropython 代码中 port 目录下的 k210-freertos 文件夹，也就是kendryte210平台的代码结构。 目录简介 简单介绍 k210-freertos 中的文件及目录 文件 代码文件 main.c 是程序入口的代码之外，如果贡献开发者需要对 main 函数进行修改我们就可以在这个文件中进行编辑 脚本文件 一般情况下，请不要对脚本文件进行修改，以免发生意外情况 config.sh 是编译时需要使用的配置脚本,主要是使用 export 配置shell环境中变量以让编译正常进行 build.sh 是用于编译代码，代码编译请看 代码编译 章节 clean_inc.sh 用于编译过程中生成的所有mk文件 flash.sh 用于 linux 环境下烧写程序 mk文件 mk文件是在编译过程中生成的中间文件，一般用于包含代码文件的路径 文件夹 代码文件夹 以下目录是用于存放 MaixPy 的所有代码 mpy_support 存放 MicroPython 与 Openmv 相关的代码 platform 存放和平台相关的代码，如sdk,驱动等等 third_party 存放可移植的第三方代码，比如spiffs 其他文件夹 output 存放编译输出文件 tools 存放开发过程需要用的工具脚本，比如打包文件系统 build 存放编译过程中.o文件，所有代码文件夹下都带有一个 build 文件夹，作用都是存放.o文件 inc 存放各个子目录的中间的mk文件，一般情况不修改该目录下的文件 docs 存放文档和例程demo 目录详解 以下我们将详细说明在开发过程中我们经常用到的目录，以方便贡献开发者可以更快上手开发 mpy_support mpy_support 文件夹是用于存放和 micropython 有关的所有代码，包括 micropython 所有平台移植代码，如 mpconfigport.h、mpconfigboard.h等等。同时也存放所有 micropython 标准模块如 os、time等等，还有常见的硬件模块，如 SPI、IIC等等 standard_lib standard_lib 用于存放 micropython 的标准库代码，比如 machine 、 socket 、 os 等等，每个模块都有自己独立的文件夹，其中 include 文件夹存放的是所有的头文件。开发标准模块时可以参考这里 omv omv 存放的是与 openmv 移植相关的代码，如果需要开发 lcd 、 sensor 、 image 等模块则可以修改该目录下的文件 Maix Maix 存放的是平台特性功能的代码，比如 FPIOA 功能，其他平台少有，所以我们将 FPIOA 的相关代码存放在 Maix 目录下。后期可能开发的功能如 I2S 、 KPU等都存放在这里。 builtin-py builtin-py 存放的是MaixPy内置的 Python 文件，Micropython支持将 Python 文件编译到固件中，我们把所有想要内置的 Python 文件都存放在这里以让这些文件可以编译进固件中。比如fm 和 board_info 等功能都是使用这里的 Python 文件实现的 platform platform 存放的是所有平台相关代码，比如 sdk 、 驱动等等 sdk sdk 存放了 kendryte210 的软件开发工具包，一般情况下我们不需要修改这里的代码 drivers drivers 存放了开发板上常见外设的代码，比如lcd 、 flash 、 sd卡等等 third_party third_party 存放了所有第三方移植代码，如果在开发过程中需要用到其他第三方的库或者功能，需要把代码存放在该目录下 spiffs spiffs 存放了spiffs文件系统的移植代码，在开放过程中，如果需要对 spiffs 文件系统进行配置修改，可以在该目录找到配置文件并修改 tools tool 是开发过程中使用到的自己编写的功能脚本，比如打包文件系统，去除固件中多余的数组等等，在开发时如果自己编写了脚本，需要将脚本放在该目录下 output output 目录存放了所有的编译最终结果，包括每个代码文件夹和第三方代码生成的静态库、输出的二进制文件和elf文件，其中我们烧录的就是二进制.bin文件 "},"contribute/":{"url":"contribute/","title":"贡献","keywords":"","body":"参与贡献 由于是开源项目，欢迎大家参与进来共同改进MaixPy， 由于人数较多，所以我们需要共同的约定（包括格式、风格等） 主要有以下几个方面可以参与进来： 文档修改 MaixPy 固件 Bug 修复、功能优化、功能新增等 "},"contribute/doc_convention.html":{"url":"contribute/doc_convention.html","title":"文档风格","keywords":"","body":"文档规范 文档使用 gitbook 进行构建， 并使用简单高效的 Markdown 编写内容 文档源码托管在 github Markdown 语法 Markdown 的基础语法如果没接触过， 请花半个小时进行学习， 推荐github的教程： github Markdown 教程 在本文中， 以下几点我们需要注意： 标题类的语法标记必须使用空格隔开，大标题与正文之间需要一个空行，比如： ## 这是二级标题 * 这是列表项1 * 这是列表项2 而如下所示的则不是正确的，可能会导致解析器出现解析错误格式错乱等 ##这是二级标题 *这是列表项1 *这是列表项2 所有页面只有一个一级标题 由于需要自动生成目录，主要是为了保证自动生成的目录正确。 每个页面这样写 页面标题/一级标题 ======= (这里等号至少需要三个) ( 至少需要一个以上的空行，建议2行 ) ## 二级标题1 ( 这里不能使用一级标题，及不能用一个#号。 也不需要写序号，会自动生成序号) ( 空一行 ) 正文 ( 至少空一行) ### 三级标题 ( 类似二级标题, 也不需要写需要，会自动生成) 正文 ## 二级标题2 正文 链接 由于页面众多，而且需要链接图片等资源，在写链接时，均使用相对路径， 比如目录结构如下 assets/ (放公用的资源文件) | ----pic000.png en/ | ----- get_started/ | ---- assets/ (放get_started目录下md文件公用的资源文件) | ------ pic.png | ---- get_hardware.md | ---- how_to_read.md zh/ 如果在get_hardware.md中贴图片，将图片放进assets文件夹后，使用如下代码引用图片 ![pic](assets/pic.png) ![pic](../../assets/pic000.png) 中英文混写 在写中文文档时，在中文中夹杂英文尽量用空格隔开，标点符号尽量使用全角符号， 主要是为了显眼，让文档更优雅。 比如如下对比： 在 Micropython 中， 我们常常使用`deinit`来表示析构函数，而不是像 STM32 一样来表示设置默认值 在 Micropython 中， 我们常常使用deinit来表示析构函数，而不是像 STM32 一样来表示设置默认值 在Micropython中， 我们常常使用deinit来表示析构函数，而不是像STM32一样来表示设置默认值 在Micropython中， 我们常常使用deinit来表示析构函数，而不是像STM32一样来表示设置默认值 目录和文件名 生成的文档目录在对应语言的文件夹SUMMARY.md中编辑 源文档的文件夹尽量一个功能模块对应一个文件夹，资源文件（图片）放置到对应 md 文档的当前路径的 assets文件夹目录下，这样在增删修改时更方便 assets/ (放公用的资源文件) en/ | ----- get_started/ | ---- assets/ (放get_started目录下md文件公用的资源文件) | ---- get_hardware.md | ---- how_to_read.md zh/ 文件名除了README.md特殊，其它文件名使用 小写+下划线 的命名方式，比如 get_hardware.md 中英文（多语言）的页面文件目录结构和文件名相同 由于最后生成的页面中有多语言切换选项，点击切换后会直接访问对应语言的相同路径，所以中英文的目录结构和文件名必须相同。 比如英文正在访问en/get_started/how_to_read.md， 点击语言切换的按钮后，会自动访问zh/get_started/how_to_read.md， 如果这个文件不存在就会报404错误！ 目录和链接 尽量引导阅读者使用目录，文内跳转链接慎用，如果链接跳得比较乱，会导致文档看起来比较乱，阅读会比较困难。 模块文档内容 需要在文件头部包含模块的介绍 需要分点说明构造函数、函数、常量等 说明不能偷懒只简单将函数名称翻译一遍，需要详细说明函数的功能、参数的取值范围以及注意点 多版本管理 文档除了做了中英文（多语言）支持（不是自动翻译，需要手动修改）， 也做了多版本管理。 每个版本是一个分支， 对分支名字有要求， 分别为： master 分支为主分支 dev分支为开发分支 其它的发布的历史版本均以小写 v 开头，比如创建一个分支叫 v1.2 创建好新的分支后，需要在每个语言版本的目录下 book.json中修改版本链接，不然读者找不到入口 可以在新建的分支下本地预览（预览方法见根目录 README.md）， 注意这时候预览的页面就是当前分支的内容，如果要本地预览其它分支内容，需要先切换到其它分之后再预览即可。 确认无误修改完成后推送分支到远程（github）， 自动构建系统会自动构建并发布到 pages 分支， 等构建完毕访问网址即可看到效果。 "},"contribute/code_convention.html":{"url":"contribute/code_convention.html","title":"代码风格","keywords":"","body":"代码规范 "},"others/open_projects.html":{"url":"others/open_projects.html","title":"开源项目","keywords":"","body":"与 MaixPy 相关的开源项目 如果你有什么跟 MaixPy 相关的开源项目， 欢迎通过邮件(support@sipeed.com)或者 issues 告诉我们，或者直接修改文档提交 PR 非常期待大家的好玩有趣或者实用的作品哦～～～ "},"get_started/prepare_knowledge.html":{"url":"get_started/prepare_knowledge.html","title":"必备基础知识","keywords":"","body":"必备基础知识 要开始使用 MaixPy， 我们建议至少有以下基础知识（当然，只是建议，临时学习也是可以的）： 有足够的耐心和细心， 能够静下心来专研技术、仔细查看文档、专心写代码 有 Python 或者 Micropython 基础， 会使用 Python 基础语法。 如果不会 Python语法， 但是有其它编程语言基础，请用百度搜一下Python 教程学习基础语法部分即可； 如果不会任何一门编程语言， 那本文档看起来会很吃力， 请先学习 Python 至少有一种单片机开发基础，能看懂基本的电路图， 目前本文档还没有针对零基础的人群的教程 需要有单片机开发经验的原因是本文档目前还没有对一些基本的术语进行教学，比如 UART是什么？ I2S 是什么？ 而且在未来也多半不会对这些基础知识进行详细地阐述 （但是实际上， 如果你善于使用搜索工具进行学习， 就算不懂也可以学习到） 了解 Micropython 是什么， 这里查看： MicroPython 语言介绍 大致上了解 Micropython 与 Python 的不同， 可以在这里：MicroPython 与 CPython（Python3） 的不同之处 查看 如果上述的几点有一点不满足， 那么建议先补足所缺， 否则学习和开发的过程将会异常艰辛！！！！ "},"get_started/maixpy_get_started_video.html":{"url":"get_started/maixpy_get_started_video.html","title":"上手视频教程","keywords":"","body":"MaixPy 视频入门教程 视频简单介绍了基本的上手过程，事实上文档上会更加详细， 视频只是提供一个比较直观的入门参考，对部分人群来说看视频入门会更加容易： 建议进入Bilibili登录看高清版本哦， 如果觉得节奏太慢可以右键调速滴～ "},"get_started/maixpyide.html":{"url":"get_started/maixpyide.html","title":"安装MaixPyIDE","keywords":"","body":"MaixPy IDE 首先需要弄清： MaixPy 使用Micropython 脚本语法，所以不像 C语言 一样需要编译，其实不用IDE也能愉快使用： 使用串口终端工具，后面会介绍 使用 IDE 则会方便在电脑上实时编辑脚本并上传到开发板以及直接在开发板上执行脚本，以及在电脑上实时查看摄像头图像、保存文件到开发板等 当然， 使用 IDE 因为压缩、传输需要耗费一部分资源，所以性能会有所降低，但对调试来说影响不大 MaixPy 固件 要使用MaixPy IDE , 固件必须是v0.3.1 版本以上, 否则MaixPyIDE上会连接不上， 使用前尽量检查固件版本和 IDE 版本，都更新到最新版以保障能正常使用 下载安装包 dl.sipeed.com 文件列表等说明 请看 最新版本文件夹下的 readme.txt 文件 安装 如果是安装程序(推荐，简单方便) Windows直接双击exe文件运行安装程序; Linux命令行给运行权限然后执行 chmod +x maixpy-ide-linux-x86_64-0.2.2.run ./maixpy-ide-linux-x86_64-0.2.2.run 如果是压缩包(7z) 则解压到文件夹 如果系统不支持7z， 则需要 下载 7z解压缩工具，然后用7z 在Linux下也可以双击压缩包进行解压！ 如果需要使用终端解压， 可以参考以下命令： sudo apt install p7zip-full 7z x maixpy-ide-linux-x86_64-0.2.2-installer-archive.7z -r -omaixpy-ide # `-o` 后面直接跟解压缩的路径, 中间没有空格. 解压后, 执行 如果是 Windows： 直接双击maixpyide来执行，可以右键固定到开始页面或者固定到任务栏方便后面使用 Linux： 执行chmod +x setup.sh ./setup.sh ./bin/maipyide.sh 测试运行 打开IDE, 上方工具栏里面选择开发板的型号. Tool-> Select Board (工具->选择开发板) 点击 connect 连接 MaixPy IDE 连接成功之后，链接按钮会由绿变红． 连接按钮下方是运行按钮，会执行当前编辑区的py文件． 再次点击运行按钮(红色), 停止运行当前代码． 上传文件 在 Tool 选项中可以选择发送文件 注意 点击连接后，不用和终端同时使用，否则会出现串口占用无法打开 "},"libs/machine/network.html":{"url":"libs/machine/network.html","title":"network","keywords":"","body":"network 该模块用于初始化各种网卡驱动，网卡具有连接路由，断开路由，查看网卡连接信息，检查是否连接等功能。 使用WiFi请确保已经接上了天线 esp8285 在部分开发板上带了 一个 使用AT方式交互的网卡模块，比如esp8285，与k210通过串口连接 引脚8是使能脚，可以创建一个GPIO对象来控制它的高低电平来实现使能和失能，也可以用它复位（先低后高），复位后需要等待一小段时间才能操作， 可以查看例程wifi_ap_scan.py esp32 目前在MaixDuino开发板中有一个 esp32 模块通过 spi 与k210相连 同时也有单独的TF插卡式模块 ESP8285_Module network.ESP8285(uart) 构造一个ESP8285网卡对象，使用该方法需要传入一个uart对象，在MaixPy目前支持的dock和GO上，是使用AT指令模块作为WiFi。所以该uart对象是与AT模块通信的对象，可以查看uart模块例程 调用此方法会初始化ESP8285， 如果失败会抛出异常 参数 uart: 与AT模块通信的UART对象 返回值 ESP8285: 网卡对象 ESP8285 connect(ssid, key) 连接热点（AP/路由器） 参数 ssid: 热点的SSID key: 热点的密码 返回值 无， 如果发生错误会抛出异常 2.2. ifconfig 查看wifi连接信息，目前network不支持设置网卡配置 nic.ifconfig() 参数 无 返回值 tuple 类型， 元素都是字符串：(ip, netmask, gateway, dns_server, dhcp_server, mac, ssid)， 如果没有查询到或者无效，值为\"0\" isconnected 查看wifi是否连接 nic.isconnected() 参数 无 返回值 True: 已经连接 False: 断开连接 disconnect 断开wifi连接 参数 无 返回值 无 scan 扫描周围的热点信息 参数 无 返回值 一个 list对象， 每个元素包含了一个字符串， 字符串来自AT模块的响应，内容和esp8285的AT指令文档所描述的相同，如下： ',,,,,,,, ,,' ：加密⽅式 0：OPEN 1：WEP 2：WPA_PSK 3：WPA2_PSK 4：WPA_WPA2_PSK 5：WPA2_Enterprise（⽬前 AT 不⽀持连接这种加密 AP） ：字符串参数，AP 的 SSID ：信号强度 ：字符串参数，AP 的 MAC 地址 ：信道号 ：AP 频偏，单位：kHz。此数值除以 2.4，可得到 ppm 值 ：频偏校准值 : 0：CIPHER_NONE 1：CIPHER_WEP40 2：CIPHER_WEP104 3：CIPHER_TKIP 4：CIPHER_CCMP 5：CIPHER_TKIP_CCMP 6：CIPHER_UNKNOWN : 定义与 相同 : bit0 代表 b 模式; bit1 代表 g 模式; bit2 代表 n 模式 若对应 bit 为 1，表示该模式使能；若对应 bit 为 0，则该模式未使能。 ：0，WPS 未使能；1，WPS 使能 比如： info_strs = ['4,\"ChinaNet-lot0\",-79,\"c8:50:e9:e8:21:3e\",1,-42,0,4,3,7,1', '4,\"TOPSTEP2G4\",-7 0,\"f8:e7:1e:0d:0d:f8\",1,-57,0,4,4,7,0'] 这看起来可能会比较奇怪，因为每个AP的信息都是一串字符，信息里面还有整型和字符串，字符串用双引号括起来的，所以拿到这个字符串后需要再次处理后再使用，比如： def wifi_deal_ap_info(info): res = [] for ap_str in info: ap_str = ap_str.split(\",\") info_one = [] for node in ap_str: if node.startswith('\"'): info_one.append(node[1:-1]) else: info_one.append(int(node)) res.append(info_one) return res info_strs = ['4,\"ChinaNet-lot0\",-79,\"c8:50:e9:e8:21:3e\",1,-42,0,4,3,7,1', '4,\"TOPSTEP2G4\",-70,\"f8:e7:1e:0d:0d:f8\",1,-57,0,4,4,7,0'] info = wifi_deal_ap_info(info_strs) print(info) 输出是： [[4, 'ChinaNet-lot0', -79, 'c8:50:e9:e8:21:3e', 1, -42, 0, 4, 3, 7, 1], [4, 'TOPSTEP2G4', -70, 'f8:e7:1e:0d:0d:f8', 1, -57, 0, 4, 4, 7, 0]] 然后比如我们需要获得所有AP的SSID只需要使用 for ap_info in info: print(ap_info[1]) enable_ap(ssid, key, chl=5, ecn=3) 打开热点 参数 ssid: SSID key： 密码 chl： WiFi信号的通道号 ecn： 加密方法， 有OPEN``WPA2_PSK等，参考本页ESP8285的常量部分， 默认值是3， 也就是ESP8285.WPA2_PSK，比如nic = network.ESP8285(uart) nic.enable_ap(\"maixpy\", \"12345678\", 5, nic.OPEN) 或者nic.enable_ap(\"maixpy\", \"12345678\", 5, network.ESP8285.OPEN) disable_ap() 关闭热点 常量 OPEN 热点的加密方式为不需要密码 WPA_PSK 热点的加密方式为 WPA_PSK WPA2_PSK 热点的加密方式为 WPA2_PSK WPA_WPA2_PSK 热点的加密方式为 WPA_WPA2_PSK 例程 参考network目录下的例程 ESP32_Module network.ESP32_SPI(cs,rst,rdy,mosi,miso,sclk) 构造一个ESP32_SPI网卡对象，需要传入对应的GPIOHS FUNC 如果传入参数数量不对，会返回错误 参数 对应引脚功能的 fpioa_func 返回值 ESP32_SPI 网卡对象 ESP32_SPI adc 读取esp32模块的adc值 参数 无 返回值 tunple，5个通道的adc值顺序是\"PIN36\", \"PIN39\", \"PIN34\", \"PIN35\", \"PIN32\" 例程 demo_esp32_read_adc.py "},"libs/Maix/i2s.html":{"url":"libs/Maix/i2s.html","title":"I2S","keywords":"","body":"I2S I2S模块主要用于驱动I2S设备，k210一共有3个I2S设备，每个设备一共有4个通道，在使用前需要对引脚进行映射管理 模块函数 构造函数 新建一个 I2S 对象 from Maix import I2S i2s_dev = I2S(device_num) 参数 device_num UART号，使用指定的 I2S，可以通过 I2S. 按tab键来补全 返回值 返回一个I2S 对象 通道配置函数 用于配置 I2S 通道，在此之前需要对引脚进行映射 i2s_dev.channel_config(channel, mode, resolution, cycles, align_mode) 参数 channel: I2S通道编号 mode: 通道传输模式，一共有接收和发送模式，录音为接受，播放为发送 resolution: 通道分辨率，即接收数据位数 cycles: 单个数据时钟数 align_mode: 通道对齐模式 返回值 无 设置采样率 用于配置 I2S 采样率 i2s_dev.set_sample_rate(sample_rate) 参数 sample_rate: 返回值 无 接收音频 使用I2S接收音频数据 audio = i2s_dev.record(points) 参数 points: 一次采集的音频点数 返回值 audio: 一个audio音频对象 发送音频 使用I2S发送音频数据 i2s_dev.play(audio) 参数 audio: 发送的音频对象 返回值 无 例程 例程1 from Maix import I2S import time fm.register(20,fm.fpioa.I2S0_IN_D0)#GO fm.register(19,fm.fpioa.I2S0_WS) fm.register(18,fm.fpioa.I2S0_SCLK) fm.register(34,fm.fpioa.I2S2_OUT_D1) fm.register(35,fm.fpioa.I2S2_SCLK) fm.register(33,fm.fpioa.I2S2_WS) sample_rate = 44*1000 rx = I2S(I2S.DEVICE_0) rx.channel_config(rx.CHANNEL_0, rx.RECEIVER, align_mode = I2S.STANDARD_MODE) rx.set_sample_rate(sample_rate) tx = I2S(I2S.DEVICE_2) tx.channel_config(tx.CHANNEL_1, tx.TRANSMITTER, align_mode = I2S.RIGHT_JUSTIFYING_MODE) tx.set_sample_rate(sample_rate) while True: audio = rx.record(256)#sampling points number must be smaller than 256 tx.play(audio) 例程2 from Maix import I2S from Maix import Audio from Maix import FFT import time fm.register(20,fm.fpioa.I2S0_IN_D0) fm.register(19,fm.fpioa.I2S0_WS) fm.register(18,fm.fpioa.I2S0_SCLK) fm.register(34,fm.fpioa.I2S2_OUT_D1) fm.register(35,fm.fpioa.I2S2_SCLK) fm.register(33,fm.fpioa.I2S2_WS) rx = I2S(I2S.DEVICE_0) rx.channel_config(rx.CHANNEL_0, rx.RECEIVER, align_mode = I2S.STANDARD_MODE) rx.set_sample_rate(16000) tx = I2S(I2S.DEVICE_2) tx.channel_config(tx.CHANNEL_1, tx.TRANSMITTER, align_mode = I2S.RIGHT_JUSTIFYING_MODE) tx.set_sample_rate(16000) while True: audio = rx.record(256) audio_data = audio.to_bytes() play_audio = Audio(audio_data) tx.play(play_audio) "},"libs/Maix/audio.html":{"url":"libs/Maix/audio.html","title":"audio","keywords":"","body":"audio 抽象的音频对象，该对象可以被当做参数传入也可以直接使用其方法来播放音频 模块函数 构造函数 构造 Audio 对象 audio.Audio(array=None, path=None, points=1024) 参数 该接口能传入一个参数，每个参数会决定不同的音频类型 array: bytearray类型的数据，可以将该数据转换为音频对象， 默认 None path: 打开的音频文件路径，目前仅支持 wav 格式， 默认 None, 注意需要标明关键字path，audio.Audio(\"/sd/1.wav\")这样是错的！！ audio.Audio(path = \"/sd/1.wav\") 才是正确的 points: 开辟有 points 个采样点数的音频缓冲，一个采样点大小为 32bit。为0的情况下将不开辟缓冲, 默认 1024 返回值 返回一个 Audio 对象 to_bytes: bytes转换函数 将音频对象中的音频数据转换为 bytearray 类型的对象 audio_data = test_audio.to_bytes() 参数 无 返回值 返回的音频数据 bytearray 对象 play_process: 播放预处理函数 用于预处理音频对象，在播放之前需要对音频文件进行解析，所以需要预处理。这里需要传入一个播放用的 I2S 设备 wav_info = test_audio.play_process(i2s_dev) 参数 i2s_dev: 用于播放的i2s设备 返回值 该 wav 文件的头部信息 ,list类型，分别是numchannels, samplerate, byterate, blockalign, bitspersample, datasize play: 播放函数 读取音频文件并且解析播放，一般配合循环来使用 参数 无 返回值 None： 格式不支持播放 0： 播放结束 1： 正在播放 finish： 音频后处理函数 完成音频播放，该函数必须在播放完毕后调用，回收底层分配的资源 参数 无 返回值 无 例程 播放 wav 音频 from fpioa_manager import * from Maix import I2S, GPIO import audio # disable wifi fm.register(8, fm.fpioa.GPIO0) wifi_en=GPIO(GPIO.GPIO0,GPIO.OUT) wifi_en.value(0) # register i2s(i2s0) pin fm.register(34,fm.fpioa.I2S0_OUT_D1) fm.register(35,fm.fpioa.I2S0_SCLK) fm.register(33,fm.fpioa.I2S0_WS) # init i2s(i2s0) wav_dev = I2S(I2S.DEVICE_0) # init audio player = audio.Audio(path = \"/sd/6.wav\") player.volume(40) # read audio info wav_info = player.play_process(wav_dev) print(\"wav file head information: \", wav_info) # config i2s according to audio info wav_dev.channel_config(wav_dev.CHANNEL_1, I2S.TRANSMITTER,resolution = I2S.RESOLUTION_16_BIT ,cycles = I2S.SCLK_CYCLES_32, align_mode = I2S.RIGHT_JUSTIFYING_MODE) wav_dev.set_sample_rate(wav_info[1]) # loop to play audio while True: ret = player.play() if ret == None: print(\"format error\") break elif ret==0: print(\"end\") break player.finish() "},"libs/Maix/freq.html":{"url":"libs/Maix/freq.html","title":"freq","keywords":"","body":"freq 频率模块，支持程序修改 cpu 和 kpu 频率 方法 frq.set(cpu, pll1, kpu_div) 设置 cpu 或者 kpu 频率，设置完后会自动重启生效 请注意在频率设置完毕后可能会导致某些外设性能改变 from Maix import freq freq.set(cpu = 400, kpu = 400) 配置文件将会保存在文件系统的/flash/freq.conf文件下，请勿修改这个文件，如果文件不存在则会自动创建 参数 不设置的参数会保持之前的值 注意： 如果cpu频率设置小于60MHz， 默认的REPL串口波特率会设置为9600 cpu： 想要设置的cpu频率，范围[26,600]（芯片最高800但对电压有要求，MaixPy支持的系列不支持最高到800，默认400, 不同的板子可能表现不同，为了稳定性不建议过高 pll1: pll1输出的频率，取值范围[26,1200]（芯片最高1800，MaixPy限制到1200），默认 400 kpu_div：kpu时钟频率分频，取值范围[1,16]，默认1。 kpu频率=pll1/kpu_div， 比如想设置kpu频率为400，则只需设置pll1为400， kpu_div为1即可。 注意kpu频率范围：[26,600] 返回值 如果频率没有变化，则返回空。 如果频率有变化，将会自动重启机器。在使用该接口之前请确认当前情况能能否重启 freq.get() 获取当前设置的频率参数 返回值 cpu频率和kpu的频率，一个元组的形式返回，比如(400,400) freq.get_cpu() 获取当前cpu的频率 返回值 cpu频率 freq.get_kpu() 获取当前设置的 kpu 频率 返回值 当前kpu频率 "}}